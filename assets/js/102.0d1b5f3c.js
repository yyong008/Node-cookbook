(window.webpackJsonp=window.webpackJsonp||[]).push([[102],{371:function(t,s,a){"use strict";a.r(s);var r=a(0),n=Object(r.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"库"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#库"}},[t._v("#")]),t._v(" 库")]),t._v(" "),a("p",[t._v("许多应用程序需要解决相同的一般问题，或在几种不同的情况下重用模块化组件。Nest有几种解决方法，但是每种方法都可以在不同级别上以有助于满足不同体系结构和组织目标的方式解决问题。")]),t._v(" "),a("p",[t._v("嵌套模块可用于提供一个执行上下文，该上下文允许在单个应用程序内共享组件。模块也可以与npm打包在一起以创建可重用的库，该库可以安装在不同的项目中。这可能是分发可配置的，可重用的库的有效方法，该库可被不同的，松散连接的或无联系的组织使用（例如，通过分发/安装第三方库）。")]),t._v(" "),a("p",[t._v("为了在组织紧密的组内（例如，在公司/项目边界内）共享代码，采用更轻量级的方法来共享组件可能很有用。Monorepo的出现就是为了实现这一点，并且在monorepo中，库提供了一种以简单，轻量级方式共享代码的方法。在Nest monorepo中，使用库可轻松组装共享组件的应用程序。实际上，这鼓励了单片应用程序和开发过程的分解，以专注于构建和组成模块化组件。")]),t._v(" "),a("h2",{attrs:{id:"nest-库"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#nest-库"}},[t._v("#")]),t._v(" Nest 库")]),t._v(" "),a("p",[t._v("Nest库是一个Nest项目，它与应用程序的不同之处在于它不能单独运行。必须将一个库导入一个包含应用程序的库中才能执行其代码。本节中描述的对库的内置支持仅适用于monorepos（标准模式项目可以使用npm软件包实现类似的功能）。")]),t._v(" "),a("p",[t._v("例如，组织可以AuthModule通过实施管理所有内部应用程序的公司策略来开发管理身份验证的。Monorepo可以为每个应用程序将该模块定义为一个库，而不是为每个应用程序分别构建该模块，或将代码与npm物理包装在一起并要求每个项目安装它。通过这种方式进行组织后，库模块的所有使用者都可以看到提交的的最新版本AuthModule。这对于协调组件开发和组装以及简化端到端测试可能具有显着的好处。")]),t._v(" "),a("h2",{attrs:{id:"创建库"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#创建库"}},[t._v("#")]),t._v(" 创建库")]),t._v(" "),a("p",[t._v("任何适合重用的功能都可以作为库进行管理。决定什么应该是库，什么应该成为应用程序的一部分是体系结构设计的决定。创建库不仅仅涉及将代码从现有应用程序复制到新库中。当打包为库时，必须将库代码与应用程序分离。这可能需要更多的时间，并迫使您做出一些设计决策，而您可能不会面对更紧密耦合的代码。但是，当可以使用该库来实现跨多个应用程序的更快的应用程序组装时，这种额外的努力可以得到回报。")]),t._v(" "),a("p",[t._v("要开始创建库，请运行以下命令：")]),t._v(" "),a("div",{staticClass:"language-sh extra-class"},[a("pre",{pre:!0,attrs:{class:"language-sh"}},[a("code",[t._v("nest g library my-library\n")])])]),a("p",[t._v("运行命令时，library原理图会提示您输入库的前缀（AKA别名）：")]),t._v(" "),a("div",{staticClass:"language-txt extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("What prefix would you like to use for the library (default: @app)?\n")])])]),a("p",[t._v("这将在工作区中创建一个名为的新项目my-library。使用原理图，将库类型的项目（如应用程序类型的项目）生成到命名文件夹中。库libs在monorepo根文件夹下管理。Nest会在libs第一次创建库时创建文件夹。")]),t._v(" "),a("p",[t._v("为库生成的文件与为应用程序生成的文件略有不同。这是libs执行上述命令后文件夹的内容：")]),t._v(" "),a("div",{staticClass:"language-tree extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("libs\nmy-library\nsrc\nmy-library.service.ts\nmy-library.module.ts\nindex.ts\ntsconfig.lib.json\n")])])]),a("p",[t._v('该nest-cli.json文件将在以下项下为库提供一个新条目"projects"：')]),t._v(" "),a("div",{staticClass:"language-json extra-class"},[a("pre",{pre:!0,attrs:{class:"language-json"}},[a("code",[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token property"}},[t._v('"my-library"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n      "),a("span",{pre:!0,attrs:{class:"token property"}},[t._v('"type"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"library"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n      "),a("span",{pre:!0,attrs:{class:"token property"}},[t._v('"root"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"libs/my-library"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n      "),a("span",{pre:!0,attrs:{class:"token property"}},[t._v('"entryFile"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"index"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n      "),a("span",{pre:!0,attrs:{class:"token property"}},[t._v('"sourceRoot"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"libs/my-library/src"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n      "),a("span",{pre:!0,attrs:{class:"token property"}},[t._v('"compilerOptions"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token property"}},[t._v('"tsConfigPath"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"libs/my-library/tsconfig.lib.json"')]),t._v("\n      "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("nest-cli.json库和应用程序之间的元数据有两个区别：")]),t._v(" "),a("p",[t._v('该"type"属性设置为"library"而不是"application"\n该"entryFile"属性设置为"index"而不是"main"\n这些差异是构建过程以适当处理库的关键。例如，一个库通过index.js文件导出其功能。')]),t._v(" "),a("p",[t._v("与应用程序类型的项目一样，每个库都有自己的tsconfig.lib.json文件，这些文件扩展了根文件（单存储范围）tsconfig.json。您可以根据需要修改此文件，以提供特定于库的编译器选项。")]),t._v(" "),a("p",[t._v("您可以使用CLI命令构建库：")]),t._v(" "),a("div",{staticClass:"language-sh extra-class"},[a("pre",{pre:!0,attrs:{class:"language-sh"}},[a("code",[t._v("nest build my-library\n")])])]),a("h2",{attrs:{id:"使用库"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#使用库"}},[t._v("#")]),t._v(" 使用库")]),t._v(" "),a("p",[t._v("有了自动生成的配置文件后，使用库就很简单了。我们如何MyLibraryService从my-library库导入my-project应用程序？")]),t._v(" "),a("p",[t._v("首先，请注意，使用库模块与使用任何其他Nest模块相同。monorepo所做的就是以一种透明的方式导入库并生成构建的方式来管理路径。要使用MyLibraryService，我们需要导入其声明模块。我们可以my-project/src/app.module.ts如下修改导入MyLibraryModule。")]),t._v(" "),a("div",{staticClass:"language-ts extra-class"},[a("pre",{pre:!0,attrs:{class:"language-ts"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("import")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" Module "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("from")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'@nestjs/common'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("import")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" AppController "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("from")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'./app.controller'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("import")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" AppService "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("from")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'./app.service'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("import")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" MyLibraryModule "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("from")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'@app/my-library'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n@"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("Module")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  imports"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("MyLibraryModule"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  controllers"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("AppController"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  providers"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("AppService"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("export")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("AppModule")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v('请注意，上面我们@app在ES模块import行中使用了路径别名，这是上面命令prefix提供的别名nest g library。在幕后，Nest通过tsconfig路径映射处理此问题。添加库时，Nest这样更新全局（monorepo）tsconfig.json文件的"paths"密钥：')]),t._v(" "),a("div",{staticClass:"language-ts extra-class"},[a("pre",{pre:!0,attrs:{class:"language-ts"}},[a("code",[a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"paths"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"@app/my-library"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"libs/my-library/src"')]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"@app/my-library/*"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"libs/my-library/src/*"')]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("因此，总而言之，monorepo和库功能的组合使将库模块包含到应用程序中变得容易而直观。")]),t._v(" "),a("p",[t._v("使用相同的机制可以构建和部署组成库的应用程序。导入后MyLibraryModule，运行会nest build自动处理所有模块分辨率，并将应用程序与任何库依赖项捆绑在一起以进行部署。monorepo的默认编译器是webpack，因此生成的分发文件是一个文件，该文件将所有已转译的JavaScript文件捆绑到一个文件中。您还可以tsc按照此处所述切换到。")])])}),[],!1,null,null,null);s.default=n.exports}}]);
(window.webpackJsonp=window.webpackJsonp||[]).push([[172],{234:function(a,t,s){"use strict";s.r(t);var r=s(0),e=Object(r.a)({},(function(){var a=this,t=a.$createElement,s=a._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h1",{attrs:{id:"why"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#why"}},[a._v("#")]),a._v(" Why")]),a._v(" "),s("p",[a._v("现代前端的程序中管理数据，带来了巨大的挑战。开发人员必须汇总来自多个来源的数据，将其分发到平台上。\n然后将其放在应用程序的 UI 中。前端数据状态管理，缓存等使用 GraphQL 将极大的改善这些特点。")]),a._v(" "),s("blockquote",[s("p",[a._v("继续阅读以了解 GraphQL 的声明式数据获取方法如何简化数据转换并加快 API 的速度。您还将了解到 Apollo 平台如何利用其先进的工具生态系统和出色的开发人员经验来加快开发周期。")])]),a._v(" "),s("h2",{attrs:{id:"开发者经验"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#开发者经验"}},[a._v("#")]),a._v(" 开发者经验")]),a._v(" "),s("ul",[s("li",[a._v("Apollo Client")]),a._v(" "),s("li",[a._v("Apollo Server")]),a._v(" "),s("li",[a._v("Apollo GraphQL Manager")])]),a._v(" "),s("h2",{attrs:{id:"探索-api"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#探索-api"}},[a._v("#")]),a._v(" 探索 API")]),a._v(" "),s("ul",[s("li",[a._v("强类型查询语言")]),a._v(" "),s("li",[a._v("GraphQL API")]),a._v(" "),s("li",[a._v("自动文档编制，自动完成")])]),a._v(" "),s("h2",{attrs:{id:"把-graphql-当成游乐园"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#把-graphql-当成游乐园"}},[a._v("#")]),a._v(" 把 GraphQL 当成游乐园")]),a._v(" "),s("ul",[s("li",[a._v("Prisma 是一个 IDE")]),a._v(" "),s("li",[a._v("Apollo Server 2+ 是开箱即用的 GrahQL Playground，因此您可以自由探索。")])]),a._v(" "),s("h2",{attrs:{id:"apollo-开发工具"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#apollo-开发工具"}},[a._v("#")]),a._v(" Apollo 开发工具")]),a._v(" "),s("p",[a._v("Apollo 是一个 Chrome 的扩展工具， 可让您检查 Apollo 客户端缓存，跟踪活动查询并查看突变。您还可以在 Apollo DevTools 中访问 GraphiQL，这在您使用 Apollo Client 处理前端代码时很方便地测试查询。")]),a._v(" "),s("h2",{attrs:{id:"简化前端代码"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#简化前端代码"}},[a._v("#")]),a._v(" 简化前端代码")]),a._v(" "),s("p",[a._v("Apollo Clinet 可以摆脱你还需要单独的书写例如 Redux 或者 REST 之内的数据状态管理。")]),a._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("import")]),a._v(" ApolloClient "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("from")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[a._v("'apollo-boost'")]),a._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("const")]),a._v(" client "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("new")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("ApolloClient")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n  uri"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[a._v("'https://dog-graphql-api.glitch.me/graphql'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n")])])]),s("p",[a._v("Apollo 支持管理本地数据和远程数据， 此您可以将 Apollo 缓存用作应用程序中所有全局状态的单个事实来源。")]),a._v(" "),s("h2",{attrs:{id:"model-manager"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#model-manager"}},[a._v("#")]),a._v(" Model Manager")]),a._v(" "),s("p",[a._v("使用 Apollo 平台开发 GraphQL API，使团队可以使用现代工具，以帮助他们快速发现错误，了解 API 并开发具有挑战性的功能，例如充满信心地进行缓存。")]),a._v(" "),s("p",[a._v("Apollo Graph Manager 是 GraphQL 生态系统中唯一可以为您的 API 提供监视和分析的工具。Graph Manager 显示每个解析器的跟踪指标，可帮助您查明错误以及架构中每个字段的性能分布。您还可以将此数据通过管道传输到您可能已经在使用的服务（例如 DataDog），并在这些数字超过特定阈值时设置 Slack 警报。")]),a._v(" "),s("h2",{attrs:{id:"声明式数据获取"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#声明式数据获取"}},[a._v("#")]),a._v(" 声明式数据获取")]),a._v(" "),s("p",[a._v("采用 GraphQL 的主要优点之一是它的声明性方法来获取数据。借助 GraphQL，无需像传统 REST 数据获取那样从客户端调用多个端点或手动聚合数据。相反，您可以指定所需的确切数据，而 GraphQL 可以为您提供所需的确切数据。")]),a._v(" "),s("p",[a._v("使用 REST，您将必须为列表中的每个项目调用所有这些终结点，过滤所需的数据，并将所有剩余数据聚合为组件使用的形状。")]),a._v(" "),s("div",{staticClass:"language-Shell extra-class"},[s("pre",{pre:!0,attrs:{class:"language-shell"}},[s("code",[a._v("GET /api/dogs/breeds\nGET /api/dogs/images\nGET /api/dogs/activities\n")])])]),s("p",[a._v("缺点：")]),a._v(" "),s("ul",[s("li",[a._v("耗时")]),a._v(" "),s("li",[a._v("容易出错")]),a._v(" "),s("li",[a._v("逻辑没有办法重用")])]),a._v(" "),s("p",[a._v("使用 GraphQL 获取数据的方式")]),a._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("const")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("GET_DOGS")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" gql"),s("span",{pre:!0,attrs:{class:"token template-string"}},[s("span",{pre:!0,attrs:{class:"token template-punctuation string"}},[a._v("`")]),s("span",{pre:!0,attrs:{class:"token string"}},[a._v("\n  query {\n    dogs {\n      id\n      bread\n      image {\n        url\n      }\n      activities {\n        name\n      }\n    }\n  }\n")]),s("span",{pre:!0,attrs:{class:"token template-punctuation string"}},[a._v("`")])]),a._v("\n")])])]),s("p",[a._v("React 应用程序中，用于检索数据，跟踪加载和错误状态以及更新 UI 的所有逻辑都封装在一个 useQuery 钩子中。这种封装使您轻松地将数据获取组件与演示组件进行组合！让我们看看如何在 React 应用程序中使用 Apollo Client 获取 GraphQL 数据：")]),a._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("function")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("Feed")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("const")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v(" loading"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" error"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" data "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("useQuery")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("GET_DOGS")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("if")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("error"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("return")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("<")]),a._v("Error "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("/")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(">")]),a._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("if")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("loading "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("||")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("!")]),a._v("data"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("return")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("<")]),a._v("Fetching "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("/")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(">")]),a._v("\n\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("return")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("<")]),a._v("DogList dogs"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("data"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("dogs"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("/")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(">")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])])]),s("p",[a._v("Apollo Client 负责从头到尾的请求周期，包括为您跟踪加载和错误状态。在发出第一个请求之前，无需设置任何中间件或编写样板文件，也无需担心转换和缓存响应。您要做的就是描述组 ​​ 件所需的数据，然后让 Apollo Client 承担繁重的工作。💪")]),a._v(" "),s("p",[a._v("您会发现，当您切换到 Apollo Client 时，将能够删除许多与数据管理有关的不必要的代码。确切的数量将根据您的应用程序而有所不同，但是一些团队报告了多达数千行。要了解有关 Apollo Client 如何以更少的代码启用高级功能（如开放式 UI，重新获取和分页）的更多信息，请查阅我们的 Apollo Client 文档。")]),a._v(" "),s("h2",{attrs:{id:"性能提升"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#性能提升"}},[a._v("#")]),a._v(" 性能提升")]),a._v(" "),s("p",[a._v("在许多情况下，在现有 REST 端点上分层 GraphQL API 可以提高应用程序的性能，尤其是在网络连接速度较慢的设备上。尽管您应该始终确定集成 GraphQL 将如何影响您的应用程序，但人们普遍认为 GraphQL 通过帮助避免往返服务器和减小有效负载大小来提高性能。")]),a._v(" "),s("h2",{attrs:{id:"较小的有效载荷"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#较小的有效载荷"}},[a._v("#")]),a._v(" 较小的有效载荷")]),a._v(" "),s("p",[a._v("由于从服务器返回的响应仅包含您在查询中指定的属性，因此与 REST 端点相比，GraphQL 可以显着减小有效负载大小。让我们看一下本文前面的 dogs 查询：")]),a._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("const")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("GET_DOGS")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" gql"),s("span",{pre:!0,attrs:{class:"token template-string"}},[s("span",{pre:!0,attrs:{class:"token template-punctuation string"}},[a._v("`")]),s("span",{pre:!0,attrs:{class:"token string"}},[a._v("\n  query {\n    dogs {\n      id\n      breed\n      image {\n        url\n      }\n      activities {\n        name\n      }\n    }\n  }\n")]),s("span",{pre:!0,attrs:{class:"token template-punctuation string"}},[a._v("`")])]),a._v("\n")])])]),s("p",[a._v("从服务器的响应背面将与狗对象的列表 id，breed，image，和 activities 属性。我们在解析器中调用的基础 REST 端点是否返回具有 100 个属性的对象都没有关系！在将响应发送回客户端之前，所有这些无关的属性都将被过滤掉。")]),a._v(" "),s("h2",{attrs:{id:"避免往返"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#避免往返"}},[a._v("#")]),a._v(" 避免往返")]),a._v(" "),s("p",[a._v("由于每个 GraphQL 请求仅返回一个响应，因此切换到 GraphQL 可以帮助您避免从客户端到服务器的昂贵往返。使用 REST，每个资源代表一个往返，可以快速累加。如果要获取列表中的项目，则必须针对每个资源乘以项目数来完成一次往返，从而导致加载时间变慢，尤其是在移动设备上。")]),a._v(" "),s("ul",[s("li",[a._v("GET /api/dogs/breeds")]),a._v(" "),s("li",[a._v("GET /api/dogs/images")]),a._v(" "),s("li",[a._v("GET /api/dogs/activities")])]),a._v(" "),s("p",[a._v("使用 GraphQL，每个查询代表从客户端到服务器的单次往返。如果您想进一步减少往返次数，则可以实施查询批处理，以将多个查询批处理到单个请求中。")]),a._v(" "),s("h2",{attrs:{id:"生产中使用-apollo"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#生产中使用-apollo"}},[a._v("#")]),a._v(" 生产中使用 Apollo")]),a._v(" "),s("p",[a._v("GraphQL 规范于 2015 年由 Facebook 首次公开发布，但 GraphQL 自 2012 年以来一直是其移动应用程序部署的关键组成部分。")]),a._v(" "),s("p",[a._v("在 Apollo，我们发现 GraphQL 是解决现有技术遇到的许多问题的绝佳解决方案，现在使用它为关键基础架构提供支持。多年来，我们一直与开源社区以及各种规模的客户和合作伙伴合作，不断为开源 Apollo 产品带来新的创新，我们为这些产品适用于从初创企业到新兴企业的所有产品感到自豪。大规模部署。")]),a._v(" "),s("p",[a._v("除了我们自己的经验之外，我们还获得了在生产中积极使用 Apollo GraphQL 的企业客户的广泛反馈，贡献和支持。我们一些最公开，最著名的案例研究是：")])])}),[],!1,null,null,null);t.default=e.exports}}]);
(window.webpackJsonp=window.webpackJsonp||[]).push([[40],{324:function(t,e,a){"use strict";a.r(e);var s=a(0),i=Object(s.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"injectable"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#injectable"}},[t._v("#")]),t._v(" Injectable")]),t._v(" "),a("p",[t._v("管道是用 @Injectable 装饰器的类。管道应实现该 PipeTransform 接口。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://docs.nestjs.com/assets/Pipe_1.png",alt:""}})]),t._v(" "),a("p",[t._v("管道有两个典型的用例")]),t._v(" "),a("ul",[a("li",[t._v("转换： 将输入的数据抓换成所需的输出")]),t._v(" "),a("li",[t._v("验证： 评估输入数据， 如需将其原样传递即可，否则，当数据不正确时抛出异常")])]),t._v(" "),a("p",[t._v("在这两种情况下，管道arguments均由控制器路由处理程序处理。Nest会在调用方法之前插入一个管道，并且管道会接收指定给该方法的参数。那时将进行任何转换或验证操作，然后使用任何（可能）转换后的参数调用路由处理程序。")]),t._v(" "),a("h2",{attrs:{id:"内置管道"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#内置管道"}},[t._v("#")]),t._v(" 内置管道")]),t._v(" "),a("ul",[a("li",[t._v("ValidationPipe")]),t._v(" "),a("li",[t._v("ParseIntPipe")]),t._v(" "),a("li",[t._v("ParseBooleanPipe")]),t._v(" "),a("li",[t._v("ParseArrayPipe")]),t._v(" "),a("li",[t._v("ParseUUIDPipe")])]),t._v(" "),a("p",[t._v("他们是从 @nestjs/common 包中导出的。为了更好的了解他们的工作，让我们构建 ValidationPipe 并从头开始。")]),t._v(" "),a("p",[t._v("让我们从开始 ValidationPipe。 最初，我们将让它简单地采用一个输入值，并立即返回相同的值，就像一个身份函数一样。")])])}),[],!1,null,null,null);e.default=i.exports}}]);
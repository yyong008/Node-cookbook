(window.webpackJsonp=window.webpackJsonp||[]).push([[104],{369:function(t,s,a){"use strict";a.r(s);var e=a(0),n=Object(e.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"nest-cli和脚本"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#nest-cli和脚本"}},[t._v("#")]),t._v(" Nest CLI和脚本")]),t._v(" "),a("p",[t._v("本节提供有关nest命令如何与编译器和脚本交互以帮助DevOps人员管理开发环境的其他背景。")]),t._v(" "),a("p",[t._v("Nest应用程序是标准的 TypeScript应用程序，需要先将其编译为JavaScript才能执行。有多种方法可以完成编译步骤，并且开发人员/团队可以自由选择最适合他们的方法。考虑到这一点，Nest提供了一系列现成的工具，它们旨在执行以下操作：")]),t._v(" "),a("p",[t._v("提供在命令行上可用的标准构建/执行过程，该过程“合理”且具有合理的默认值。\n确保构建/执行过程是开放的，以便开发人员可以直接访问基础工具以使用本机功能和选项对其进行自定义。\n保留一个完全标准的TypeScript / Node.js框架，以便可以由开发团队选择使用的任何外部工具来管理整个编译/部署/执行管道。\n通过结合使用nest命令，本地安装的TypeScript编译器和package.json脚本来实现此目标。我们在下面描述这些技术如何协同工作。这应该有助于您了解在构建/执行过程的每个步骤中发生了什么，以及在必要时如何自定义该行为。")]),t._v(" "),a("h2",{attrs:{id:"嵌套二进制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#嵌套二进制"}},[t._v("#")]),t._v(" 嵌套二进制")]),t._v(" "),a("p",[t._v("该nest命令是OS级别的二进制文件（即，从OS命令行运行）。该命令实际上包含3个不同的区域，如下所述。我们建议您在搭建项目时通过自动提供的脚本运行build（nest build）和execute（nest start）子命令package.json（如果您希望通过克隆存储库而不是运行来启动，请参阅打字稿启动器nest new）。")]),t._v(" "),a("h3",{attrs:{id:"版本号"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#版本号"}},[t._v("#")]),t._v(" 版本号")]),t._v(" "),a("p",[t._v("nest build是在标准tsc编译器（对于标准项目）或webpack编译器（对于monorepos）之上的包装。它不添加任何其他编译功能或步骤。存在的原因是，大多数开发人员，尤其是从Nest入手的开发人员，不需要调整tsconfig.json有时可能很棘手的编译器选项（例如，文件）。")]),t._v(" "),a("p",[t._v("有关更多详细信息，请参见嵌套构建文档。")]),t._v(" "),a("h3",{attrs:{id:"执行"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#执行"}},[t._v("#")]),t._v(" 执行")]),t._v(" "),a("p",[t._v("nest start只需确保已构建项目（与相同nest build），然后node以可移植，简单的方式调用命令即可执行已编译的应用程序。与构建一样，您可以根据需要自由定制此过程，可以使用nest start命令及其选项，也可以完全替换它。整个过程是标准的TypeScript应用程序构建和执行管道，您可以自由地管理该过程。")]),t._v(" "),a("p",[t._v("有关更多详细信息，请参见嵌套启动文档。")]),t._v(" "),a("h3",{attrs:{id:"生成器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#生成器"}},[t._v("#")]),t._v(" 生成器")]),t._v(" "),a("p",[t._v("nest generate顾名思义，这些命令会在其中生成新的Nest项目或组件。")]),t._v(" "),a("h3",{attrs:{id:"包脚本"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#包脚本"}},[t._v("#")]),t._v(" 包脚本")]),t._v(" "),a("p",[t._v("nest在OS命令级别运行命令需要在nest全局安装二进制文件。这是npm的标准功能，在Nest的直接控制范围之外。其结果之一是，全局安装的nest二进制文件未在中作为项目依赖项进行管理package.json。例如，两个不同的开发人员可以运行两个不同版本的nest二进制文件。对此的标准解决方案是使用程序包脚本，以便您可以将构建中使用的工具视为执行依赖并执行步骤。")]),t._v(" "),a("p",[t._v("当您运行nest new或克隆打字稿启动器时，Nest package.json使用诸如build和的命令填充新项目的脚本start。它还将基础编译器工具（例如typescript）安装为dev依赖项。")]),t._v(" "),a("p",[t._v("您可以使用以下命令运行构建并执行脚本：")]),t._v(" "),a("div",{staticClass:"language-ts extra-class"},[a("pre",{pre:!0,attrs:{class:"language-ts"}},[a("code",[t._v("$ npm run build\n\n$ npm run start\n")])])]),a("p",[t._v("这些命令使用npm的脚本运行功能来执行nest build或nest start使用本地安装的nest二进制文件。通过使用这些内置的程序包脚本，您可以通过Nest CLI命令*进行完全的依赖项管理。这意味着，通过遵循此推荐用法，可以确保组织中的所有成员都运行相同版本的命令。")]),t._v(" "),a("p",[t._v("*这适用于build和start命令。该nest new和nest generate命令不构建的一部分/执行流水线，让他们在不同的上下文中进行操作，并且没有附带内置的package.json脚本。")]),t._v(" "),a("p",[t._v("对于大多数开发人员/团队，建议利用软件包脚本来构建和执行其Nest项目。您可以通过它们的选项（--path，，）完全自定义这些脚本的行为--webpack，--webpackPath和/或根据需要自定义tsc或webpack编译器选项文件（例如tsconfig.json）。您还可以自由运行一个完全自定义的构建过程来编译TypeScript（甚至直接使用来执行TypeScript ts-node）。")]),t._v(" "),a("h2",{attrs:{id:"向后兼容"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#向后兼容"}},[t._v("#")]),t._v(" 向后兼容")]),t._v(" "),a("p",[t._v("由于Nest应用程序是纯TypeScript应用程序，因此先前版本的Nest构建/执行脚本将继续运行。您不需要升级它们。您可以选择在准备就绪时利用new nest build和nest start命令，或者继续运行以前的或自定义的脚本")]),t._v(" "),a("h2",{attrs:{id:"迁移"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#迁移"}},[t._v("#")]),t._v(" 迁移")]),t._v(" "),a("p",[t._v("尽管不需要进行任何更改，但是您可能希望迁移到使用新的CLI命令，而不是使用诸如tsc-watch或的工具ts-node。在这种情况下，只需@nestjs/cli在全局和本地安装的最新版本：")]),t._v(" "),a("div",{staticClass:"language-sh extra-class"},[a("pre",{pre:!0,attrs:{class:"language-sh"}},[a("code",[t._v("$ "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("npm")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("install")]),t._v(" -g @nestjs/cli\n$ "),a("span",{pre:!0,attrs:{class:"token builtin class-name"}},[t._v("cd")]),t._v("  /some/project/root/folder\n$ "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("npm")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("install")]),t._v(" -D @nestjs/cli\n")])])]),a("p",[t._v("然后，您可以用以下内容替换中的scripts定义package.json：")]),t._v(" "),a("div",{staticClass:"language-sh extra-class"},[a("pre",{pre:!0,attrs:{class:"language-sh"}},[a("code",[a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"build"')]),a("span",{pre:!0,attrs:{class:"token builtin class-name"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"nest build"')]),t._v(",\n"),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"start"')]),a("span",{pre:!0,attrs:{class:"token builtin class-name"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"nest start"')]),t._v(",\n"),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"start:dev"')]),a("span",{pre:!0,attrs:{class:"token builtin class-name"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"nest start --watch"')]),t._v(",\n"),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"start:debug"')]),a("span",{pre:!0,attrs:{class:"token builtin class-name"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"nest start --debug --watch"')]),t._v(",\n")])])])])}),[],!1,null,null,null);s.default=n.exports}}]);
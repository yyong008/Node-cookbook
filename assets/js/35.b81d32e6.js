(window.webpackJsonp=window.webpackJsonp||[]).push([[35],{257:function(t,s,a){"use strict";a.r(s);var n=a(0),e=Object(n.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"控制器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#控制器"}},[t._v("#")]),t._v(" 控制器")]),t._v(" "),a("p",[t._v("控制器负责处理传入的请求并将响应返回给客户端。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://docs.nestjs.com/assets/Controllers_1.png",alt:"alt"}})]),t._v(" "),a("p",[t._v("控制器的目的是接收对应用程序的特定请求。在路由该控制器接收哪些请求机构的控制。通常，每个控制器具有多个路由，并且不同的路由可以执行不同的操作。")]),t._v(" "),a("p",[t._v("为了创建一个基本的控制器，我们使用类和装饰器。装饰器将类与所需的元数据相关联，并使Nest能够创建路由映射（将请求绑定到相应的控制器）。")]),t._v(" "),a("h2",{attrs:{id:"路由"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#路由"}},[t._v("#")]),t._v(" 路由")]),t._v(" "),a("p",[t._v("在下面的示例中，我们将使用@Controller()装饰器，它是定义基本控制器所必需的。我们将指定一个可选的路由路径前缀cats。在@Controller()装饰器中使用路径前缀可以使我们轻松地对一组相关的路由进行分组，并最大程度地减少重复代码。例如，我们可以选择对一组路由进行分组，以管理与该路由下的客户实体的互动/customers。在这种情况下，我们可以customers在@Controller()装饰器中指定路径前缀，这样就不必为文件中的每个路由重复路径的那部分。")]),t._v(" "),a("div",{staticClass:"language-ts extra-class"},[a("pre",{pre:!0,attrs:{class:"language-ts"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("import")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("  Controller"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" Get "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("from")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'@nestjs/common'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n@"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("Controller")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'cats'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("export")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("CatsController")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  @"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("Get")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("findAll")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" String "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'This action returns all cats'")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),a("p",[t._v("提示\n要使用CLI创建控制器，只需执行$ nest g controller cats命令。")])]),t._v(" "),a("p",[t._v("@Get()在该findAll()方法告诉Nest为HTTP请求的特定终结点创建处理程序之前，该方法将使用HTTP请求方法装饰器。端点对应于HTTP请求方法（在这种情况下为GET）和路由路径。路线是什么？处理程序的路由路径是通过将为控制器声明的（可选）前缀与请求装饰器中指定的任何路径串联起来来确定的。由于我们为每个路由（cats）声明了前缀，并且未在装饰器中添加任何路径信息，因此Nest会将GET /cats请求映射到此处理程序。如前所述，该路径包括可选的控制器路径前缀和在请求方法装饰器中声明的任何路径字符串。例如，路径前缀customers与装饰器组合@Get('profile')会为的请求生成路由映射GET /customers/profile。")]),t._v(" "),a("p",[t._v("在上面的示例中，当对此端点发出GET请求时，Nest将请求路由到我们的用户定义的findAll()方法。请注意，我们在此处选择的方法名称完全是任意的。显然，我们必须声明一个将路由绑定到的方法，但是Nest不会对选择的方法名称赋予任何意义。")]),t._v(" "),a("p",[t._v("此方法将返回200状态代码和相关的响应，在这种情况下，响应只是一个字符串。为什么会这样呢？为说明起见，我们将首先介绍Nest运用两个不同的选项来操纵响应的概念：")]),t._v(" "),a("ul",[a("li",[t._v("标准（推荐）:")])]),t._v(" "),a("p",[t._v("使用此内置方法，当请求处理程序返回JavaScript对象或数组时，它将自动序列化为JSON。当它返回一个JavaScript基本类型（例如string，number，boolean），但是，鸟巢将不试图序列它仅发送值。这使响应处理变得简单：只需返回值，Nest会处理其余的事情。")]),t._v(" "),a("p",[t._v("此外，响应的状态码默认情况下始终为200，但使用201的POST请求除外。我们可以通过@HttpCode(...)在处理程序级别添加装饰器来轻松更改此行为（请参见状态码）。")]),t._v(" "),a("ul",[a("li",[t._v("特定库")])]),t._v(" "),a("p",[t._v("我们可以使用特定于库的（例如Express）响应对象，可以使用@Res()装饰器将其注入到方法处理程序签名（例如findAll(@Res() response)）中。使用这种方法，您有能力（也有责任）使用该对象公开的本机响应处理方法。例如，使用Express，您可以使用以下代码构建响应response.status(200).send()")]),t._v(" "),a("div",{staticClass:"custom-block warning"},[a("p",{staticClass:"custom-block-title"},[t._v("WARNING")]),t._v(" "),a("p",[t._v("警告\n您不能同时使用两种方法。Nest检测到处理程序何时使用@Res()或@Next()，指示您已选择特定于库的选项。如果同时使用两种方法，则将针对该单条路线自动禁用 “标准”方法，并且该方法将不再按预期工作。")])]),t._v(" "),a("h2",{attrs:{id:"请求对象"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#请求对象"}},[t._v("#")]),t._v(" 请求对象")]),t._v(" "),a("p",[t._v("处理程序通常需要访问客户端请求详细信息。Nest提供对基础平台的请求对象的访问（默认情况下为Express）。我们可以通过将@Req()装饰器添加到处理程序的签名中来指示Nest注入请求对象，从而访问该请求对象。")]),t._v(" "),a("div",{staticClass:"language-ts extra-class"},[a("pre",{pre:!0,attrs:{class:"language-ts"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("import")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" Controller"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" Get"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" Req "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("from")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'@nestjs/common'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("import")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" Request "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("from")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'express'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n@"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("Controller")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'cats'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("export")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("CatsController")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  @"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("Get")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("findAll")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("@"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("Req")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" request"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" Request"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("string")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token template-string"}},[a("span",{pre:!0,attrs:{class:"token template-punctuation string"}},[t._v("`")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("this action returns all cats")]),a("span",{pre:!0,attrs:{class:"token template-punctuation string"}},[t._v("`")])]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),a("p",[t._v("提示\n为了利用express键入功能（如request: Request上面的参数示例中所示），请安装@types/express软件包。")])]),t._v(" "),a("p",[t._v("equest对象代表HTTP请求，并具有请求查询字符串，参数，HTTP标头和正文的属性（在此处了解更多信息）。在大多数情况下，无需手动获取这些属性。我们可以改用专用的装饰器，例如@Body()或@Query()，它们是开箱即用的。以下是提供的装饰器及其代表的普通平台特定对象的列表。")]),t._v(" "),a("p",[t._v("@Request()\treq\n@Response(), @Res()*\tres\n@Next()\tnext\n@Session()\treq.session\n@Param(key?: string)\treq.params / req.params[key]\n@Body(key?: string)\treq.body / req.body[key]\n@Query(key?: string)\treq.query / req.query[key]\n@Headers(name?: string)\treq.headers / req.headers[name]\n@Ip()\treq.ip")]),t._v(" "),a("p",[t._v("*为了与跨基础HTTP平台（例如Express和Fastify）的键入兼容，Nest提供@Res()和@Response()装饰器。@Res()只是的别名@Response()。两者都直接公开底层的本机平台response对象接口。使用它们时，您还应该导入基础库的类型（例如@types/express）以充分利用。请注意，当您注入一个@Res()或@Response()一个方法处理程序时，您会将Nest置于该处理程序的特定于库的模式下，并负责管理响应。这样做时，您必须通过调用response对象（例如res.json(...)或res.send(...)）来发出某种响应，否则HTTP服务器将挂起。")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),a("p",[t._v("提示\n要了解如何创建自己的自定义装饰，参观这个章节。")])]),t._v(" "),a("h2",{attrs:{id:"资源"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#资源"}},[t._v("#")]),t._v(" 资源")]),t._v(" "),a("p",[t._v("之前，我们定义了一个端点来获取cats资源（GET路由）。我们通常还希望提供一个可以创建新记录的端点。为此，让我们创建POST处理程序：")]),t._v(" "),a("div",{staticClass:"language-ts extra-class"},[a("pre",{pre:!0,attrs:{class:"language-ts"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("import")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" Controller"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" Get"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" Post "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("from")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'@nestjs/common'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n@"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("Controller")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'cats'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("export")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("CatsController")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  @"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("post")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("create")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("string")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'This action adds a new cat'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n  @"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("Get")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("findAll")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("string")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'This action returns all cats'")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("就这么简单。巢提供了标准的HTTP请求端点装饰的其余部分以相同的方式- ，@Put()，@Delete()，@Patch()，@Options()，@Head()和@All()。每个代表各自的HTTP请求方法。")]),t._v(" "),a("h2",{attrs:{id:"路线通配符"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#路线通配符"}},[t._v("#")]),t._v(" 路线通配符")]),t._v(" "),a("div",{staticClass:"language-ts extra-class"},[a("pre",{pre:!0,attrs:{class:"language-ts"}},[a("code",[t._v("@"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("Get")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("findAll")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'This is 。。。。'")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("该'ab"),a("em",[t._v("cd'路由路径匹配abcd，ab_cd，abecd，等等。字符?，+，")]),t._v("，和()可在路由路径中使用，并且是其正则表达式的对应的子集。连字符（-）和点（.）由基于字符串的路径按字面意义进行解释。")]),t._v(" "),a("h2",{attrs:{id:"代码状态"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#代码状态"}},[t._v("#")]),t._v(" 代码状态")]),t._v(" "),a("p",[t._v("如前所述，默认情况下，响应状态代码始终为200，但POST请求为201。我们可以通过@HttpCode(...)在处理程序级别添加装饰器来轻松更改此行为。")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[t._v("@"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("Post")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n@"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("HttpCode")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("204")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("create")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'This action adds a new cat'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),a("p",[t._v("提示\nHttpCode从@nestjs/common包中导入。")])]),t._v(" "),a("h2",{attrs:{id:"header"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#header"}},[t._v("#")]),t._v(" Header")]),t._v(" "),a("p",[t._v("要指定自定义响应头，可以使用@Header()装饰器或特定于库的响应对象（并res.header()直接调用）。")]),t._v(" "),a("div",{staticClass:"language-ts extra-class"},[a("pre",{pre:!0,attrs:{class:"language-ts"}},[a("code",[t._v("@"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("Post")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n@"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("Header")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'Cache-Control'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'none'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("create")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'this 。。。'")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),a("p",[t._v("提示\nHeader从@nestjs/common包中导入。")])]),t._v(" "),a("h2",{attrs:{id:"重定向"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#重定向"}},[t._v("#")]),t._v(" 重定向")]),t._v(" "),a("p",[t._v("要将响应重定向到特定的URL，可以使用@Redirect()装饰器或特定于库的响应对象（并res.redirect()直接调用）。")]),t._v(" "),a("p",[t._v("@Redirect()接受必需的url参数和可选的statusCode参数。如果省略，则statusCode默认为302（Found）。")]),t._v(" "),a("div",{staticClass:"language-ts extra-class"},[a("pre",{pre:!0,attrs:{class:"language-ts"}},[a("code",[t._v("@"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("Get")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n@"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("Redirect")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'https://nestjs.com'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("301")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),a("p",[t._v("有时您可能想动态确定HTTP状态代码或重定向URL。通过从路由处理程序方法返回一个形状为以下形式的对象。")]),t._v(" "),a("div",{staticClass:"language-json extra-class"},[a("pre",{pre:!0,attrs:{class:"language-json"}},[a("code",[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token property"}},[t._v('"url"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" string"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token property"}},[t._v('"statusCode"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" number\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("返回的值将覆盖传递给@Redirect()装饰器的所有参数。例如：")]),t._v(" "),a("div",{staticClass:"language-ts extra-class"},[a("pre",{pre:!0,attrs:{class:"language-ts"}},[a("code",[t._v("@"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("Get")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'docs'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n@"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("Redirect")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'https://docs.nestjs.com'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("302")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("getDocs")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("@"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("Query")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'version'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" version"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("version "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&&")]),t._v(" version "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("===")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'5'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" url"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'https://docs.nestjs.com/v5/'")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("h2",{attrs:{id:"路由参数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#路由参数"}},[t._v("#")]),t._v(" 路由参数")]),t._v(" "),a("h2",{attrs:{id:"子域路由"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#子域路由"}},[t._v("#")]),t._v(" 子域路由")]),t._v(" "),a("h2",{attrs:{id:"范围"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#范围"}},[t._v("#")]),t._v(" 范围")]),t._v(" "),a("p",[t._v("对于来自不同编程语言背景的人们来说，意外地发现在Nest中几乎所有内容都是在传入请求之间共享的。我们有到数据库的连接池，具有全局状态的单例服务等。请记住，Node.js并不遵循请求/响应多线程无状态模型，在该模型中，每个请求都由单独的线程处理。因此，使用单例实例对于我们的应用程序是完全安全的。")]),t._v(" "),a("p",[t._v("但是，在某些情况下，控制器的基于请求的生存期可能是所需的行为，例如GraphQL应用程序中的每个请求缓存，请求跟踪或多租户。在此处了解如何控制范围。")]),t._v(" "),a("h2",{attrs:{id:"异步"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#异步"}},[t._v("#")]),t._v(" 异步")]),t._v(" "),a("p",[t._v("我们喜欢现代JavaScript，并且我们知道数据提取主要是异步的。这就是为什么Nest支持async功能并与功能完美配合的原因。")]),t._v(" "),a("h2",{attrs:{id:"请求的有效载荷"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#请求的有效载荷"}},[t._v("#")]),t._v(" 请求的有效载荷")]),t._v(" "),a("p",[t._v("我们之前的POST路由处理程序示例不接受任何客户端参数。让我们通过在@Body()此处添加装饰器来解决此问题。")]),t._v(" "),a("p",[t._v("但是首先（如果您使用TypeScript），我们需要确定DTO（数据传输对象）架构。DTO是定义如何在网络上发送数据的对象。我们可以通过使用TypeScript接口或简单的类来确定DTO模式。有趣的是，我们建议在这里使用类。为什么？类是JavaScript ES6标准的一部分，因此，它们在编译的JavaScript中保留为真实实体。另一方面，由于TypeScript接口是在转译过程中删除的，因此Nest无法在运行时引用它们。这很重要，因为诸如Pipes之类的功能在运行时可以访问变量的元类型时，它们提供了更多的可能性。")]),t._v(" "),a("h2",{attrs:{id:"处理错误"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#处理错误"}},[t._v("#")]),t._v(" 处理错误")]),t._v(" "),a("h2",{attrs:{id:"全部的资源示例"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#全部的资源示例"}},[t._v("#")]),t._v(" 全部的资源示例")]),t._v(" "),a("h2",{attrs:{id:"开始和运行"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#开始和运行"}},[t._v("#")]),t._v(" 开始和运行")]),t._v(" "),a("h2",{attrs:{id:"附录：库和具体的做法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#附录：库和具体的做法"}},[t._v("#")]),t._v(" 附录：库和具体的做法")])])}),[],!1,null,null,null);s.default=e.exports}}]);
<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>解释器 =&gt; Resolvers | NodeJS</title>
    <meta name="description" content="Learn Cookbook">
    
    
    <link rel="preload" href="/assets/css/0.styles.34788bb2.css" as="style"><link rel="preload" href="/assets/js/app.12ca0aa8.js" as="script"><link rel="preload" href="/assets/js/2.74bffc86.js" as="script"><link rel="preload" href="/assets/js/71.00f8f464.js" as="script"><link rel="prefetch" href="/assets/js/10.b17cd786.js"><link rel="prefetch" href="/assets/js/100.49143f76.js"><link rel="prefetch" href="/assets/js/101.58f5e966.js"><link rel="prefetch" href="/assets/js/102.0d1b5f3c.js"><link rel="prefetch" href="/assets/js/103.d2dfeb4d.js"><link rel="prefetch" href="/assets/js/104.221dfde0.js"><link rel="prefetch" href="/assets/js/105.89693a0d.js"><link rel="prefetch" href="/assets/js/106.dd9b2874.js"><link rel="prefetch" href="/assets/js/107.b128334b.js"><link rel="prefetch" href="/assets/js/108.d0fceeff.js"><link rel="prefetch" href="/assets/js/109.a36abbdb.js"><link rel="prefetch" href="/assets/js/11.3a5bf6a3.js"><link rel="prefetch" href="/assets/js/110.24de8f58.js"><link rel="prefetch" href="/assets/js/111.ad2322c5.js"><link rel="prefetch" href="/assets/js/112.ebf5a5e6.js"><link rel="prefetch" href="/assets/js/113.945153eb.js"><link rel="prefetch" href="/assets/js/114.89fb0b54.js"><link rel="prefetch" href="/assets/js/115.32747b75.js"><link rel="prefetch" href="/assets/js/116.2ac5709d.js"><link rel="prefetch" href="/assets/js/117.33f44883.js"><link rel="prefetch" href="/assets/js/118.080ca422.js"><link rel="prefetch" href="/assets/js/119.3696781e.js"><link rel="prefetch" href="/assets/js/12.49c205ea.js"><link rel="prefetch" href="/assets/js/120.8629050e.js"><link rel="prefetch" href="/assets/js/121.c541c819.js"><link rel="prefetch" href="/assets/js/122.0beeab62.js"><link rel="prefetch" href="/assets/js/123.f4aacc83.js"><link rel="prefetch" href="/assets/js/124.7b0ddfcc.js"><link rel="prefetch" href="/assets/js/125.b8173440.js"><link rel="prefetch" href="/assets/js/126.9ee9486f.js"><link rel="prefetch" href="/assets/js/127.6c6aee84.js"><link rel="prefetch" href="/assets/js/128.8100734d.js"><link rel="prefetch" href="/assets/js/129.adb74c9f.js"><link rel="prefetch" href="/assets/js/13.b12048d4.js"><link rel="prefetch" href="/assets/js/130.7dbfe596.js"><link rel="prefetch" href="/assets/js/131.a32c075c.js"><link rel="prefetch" href="/assets/js/132.6a0aa273.js"><link rel="prefetch" href="/assets/js/133.52f806e2.js"><link rel="prefetch" href="/assets/js/134.a196478b.js"><link rel="prefetch" href="/assets/js/135.83dc683e.js"><link rel="prefetch" href="/assets/js/136.e31ffd18.js"><link rel="prefetch" href="/assets/js/137.c9dbde0b.js"><link rel="prefetch" href="/assets/js/138.4d1cd5eb.js"><link rel="prefetch" href="/assets/js/139.432cf5af.js"><link rel="prefetch" href="/assets/js/14.daaf0416.js"><link rel="prefetch" href="/assets/js/140.f86409f6.js"><link rel="prefetch" href="/assets/js/141.3abe86ad.js"><link rel="prefetch" href="/assets/js/142.4f6fc92f.js"><link rel="prefetch" href="/assets/js/143.1535cab9.js"><link rel="prefetch" href="/assets/js/144.eefe99f6.js"><link rel="prefetch" href="/assets/js/145.0a2bc4ed.js"><link rel="prefetch" href="/assets/js/146.0e7b17e8.js"><link rel="prefetch" href="/assets/js/147.aecc5e52.js"><link rel="prefetch" href="/assets/js/148.55697156.js"><link rel="prefetch" href="/assets/js/149.78d2096d.js"><link rel="prefetch" href="/assets/js/15.45e9a802.js"><link rel="prefetch" href="/assets/js/150.e6c87191.js"><link rel="prefetch" href="/assets/js/151.a8009d6e.js"><link rel="prefetch" href="/assets/js/152.63d8fdec.js"><link rel="prefetch" href="/assets/js/153.3bfc0798.js"><link rel="prefetch" href="/assets/js/154.65d2ca87.js"><link rel="prefetch" href="/assets/js/155.6eeb8114.js"><link rel="prefetch" href="/assets/js/156.651636fd.js"><link rel="prefetch" href="/assets/js/157.91eccdc2.js"><link rel="prefetch" href="/assets/js/158.dbf5b9d8.js"><link rel="prefetch" href="/assets/js/159.823f0880.js"><link rel="prefetch" href="/assets/js/16.e71df8d4.js"><link rel="prefetch" href="/assets/js/160.cfed749a.js"><link rel="prefetch" href="/assets/js/161.84daf4cb.js"><link rel="prefetch" href="/assets/js/162.ceb37edb.js"><link rel="prefetch" href="/assets/js/163.d225972f.js"><link rel="prefetch" href="/assets/js/164.74f77e4a.js"><link rel="prefetch" href="/assets/js/165.e158fe5d.js"><link rel="prefetch" href="/assets/js/166.c41de610.js"><link rel="prefetch" href="/assets/js/167.7df65d3f.js"><link rel="prefetch" href="/assets/js/168.919437c8.js"><link rel="prefetch" href="/assets/js/169.9bcafe9d.js"><link rel="prefetch" href="/assets/js/17.7dc7c03f.js"><link rel="prefetch" href="/assets/js/170.f33f16fb.js"><link rel="prefetch" href="/assets/js/171.59cd7a83.js"><link rel="prefetch" href="/assets/js/172.e059a6f4.js"><link rel="prefetch" href="/assets/js/173.811a1b3e.js"><link rel="prefetch" href="/assets/js/174.e8d72986.js"><link rel="prefetch" href="/assets/js/175.3ee31f58.js"><link rel="prefetch" href="/assets/js/176.437ff1a6.js"><link rel="prefetch" href="/assets/js/177.0d04f570.js"><link rel="prefetch" href="/assets/js/178.45296cb6.js"><link rel="prefetch" href="/assets/js/179.4176b858.js"><link rel="prefetch" href="/assets/js/18.7d64b721.js"><link rel="prefetch" href="/assets/js/180.a2c20ea9.js"><link rel="prefetch" href="/assets/js/181.77390ab1.js"><link rel="prefetch" href="/assets/js/182.8ebcfdac.js"><link rel="prefetch" href="/assets/js/183.8a6b9bc8.js"><link rel="prefetch" href="/assets/js/184.a8587cd6.js"><link rel="prefetch" href="/assets/js/185.763d219b.js"><link rel="prefetch" href="/assets/js/186.d1c67c82.js"><link rel="prefetch" href="/assets/js/187.d0379152.js"><link rel="prefetch" href="/assets/js/188.3935a5a7.js"><link rel="prefetch" href="/assets/js/189.d40e35ad.js"><link rel="prefetch" href="/assets/js/19.1f322990.js"><link rel="prefetch" href="/assets/js/190.f5168c2b.js"><link rel="prefetch" href="/assets/js/191.00fd22a9.js"><link rel="prefetch" href="/assets/js/192.bb76bc33.js"><link rel="prefetch" href="/assets/js/193.0028d6ac.js"><link rel="prefetch" href="/assets/js/194.504c913a.js"><link rel="prefetch" href="/assets/js/195.6d91833a.js"><link rel="prefetch" href="/assets/js/20.520e4112.js"><link rel="prefetch" href="/assets/js/21.1da5f168.js"><link rel="prefetch" href="/assets/js/22.d42c6e1f.js"><link rel="prefetch" href="/assets/js/23.158333f0.js"><link rel="prefetch" href="/assets/js/24.4933f40a.js"><link rel="prefetch" href="/assets/js/25.057c428c.js"><link rel="prefetch" href="/assets/js/26.de289859.js"><link rel="prefetch" href="/assets/js/27.b14ef5da.js"><link rel="prefetch" href="/assets/js/28.b1329e69.js"><link rel="prefetch" href="/assets/js/29.49d46c7a.js"><link rel="prefetch" href="/assets/js/3.9fae61cb.js"><link rel="prefetch" href="/assets/js/30.83d321ec.js"><link rel="prefetch" href="/assets/js/31.65f56091.js"><link rel="prefetch" href="/assets/js/32.78fcc539.js"><link rel="prefetch" href="/assets/js/33.87e5077b.js"><link rel="prefetch" href="/assets/js/34.a4bf065f.js"><link rel="prefetch" href="/assets/js/35.b81d32e6.js"><link rel="prefetch" href="/assets/js/36.9ef245a6.js"><link rel="prefetch" href="/assets/js/37.4e2664a6.js"><link rel="prefetch" href="/assets/js/38.f8b21767.js"><link rel="prefetch" href="/assets/js/39.294b2e23.js"><link rel="prefetch" href="/assets/js/4.554dccb8.js"><link rel="prefetch" href="/assets/js/40.a35c8bd3.js"><link rel="prefetch" href="/assets/js/41.d60f7eb3.js"><link rel="prefetch" href="/assets/js/42.30f5ce46.js"><link rel="prefetch" href="/assets/js/43.101904fa.js"><link rel="prefetch" href="/assets/js/44.475772ec.js"><link rel="prefetch" href="/assets/js/45.58a6227c.js"><link rel="prefetch" href="/assets/js/46.045cad94.js"><link rel="prefetch" href="/assets/js/47.63628bb5.js"><link rel="prefetch" href="/assets/js/48.4f86f4a6.js"><link rel="prefetch" href="/assets/js/49.92a2af24.js"><link rel="prefetch" href="/assets/js/5.bfcb02d1.js"><link rel="prefetch" href="/assets/js/50.b7fd8454.js"><link rel="prefetch" href="/assets/js/51.9bbf3588.js"><link rel="prefetch" href="/assets/js/52.53f6da60.js"><link rel="prefetch" href="/assets/js/53.b415231c.js"><link rel="prefetch" href="/assets/js/54.53388fc4.js"><link rel="prefetch" href="/assets/js/55.fc24bc21.js"><link rel="prefetch" href="/assets/js/56.9b3c2535.js"><link rel="prefetch" href="/assets/js/57.ba13dd55.js"><link rel="prefetch" href="/assets/js/58.9a4c6a43.js"><link rel="prefetch" href="/assets/js/59.96e435e7.js"><link rel="prefetch" href="/assets/js/6.95fccca8.js"><link rel="prefetch" href="/assets/js/60.d17a46b6.js"><link rel="prefetch" href="/assets/js/61.0860ef3f.js"><link rel="prefetch" href="/assets/js/62.713860bc.js"><link rel="prefetch" href="/assets/js/63.38e7edcf.js"><link rel="prefetch" href="/assets/js/64.176f8bbb.js"><link rel="prefetch" href="/assets/js/65.903f4b50.js"><link rel="prefetch" href="/assets/js/66.1c5277a5.js"><link rel="prefetch" href="/assets/js/67.abfce232.js"><link rel="prefetch" href="/assets/js/68.37814697.js"><link rel="prefetch" href="/assets/js/69.c77c3c67.js"><link rel="prefetch" href="/assets/js/7.d035404c.js"><link rel="prefetch" href="/assets/js/70.742159c8.js"><link rel="prefetch" href="/assets/js/72.c8145491.js"><link rel="prefetch" href="/assets/js/73.edd94acd.js"><link rel="prefetch" href="/assets/js/74.deb52f36.js"><link rel="prefetch" href="/assets/js/75.5969aaa2.js"><link rel="prefetch" href="/assets/js/76.24433b28.js"><link rel="prefetch" href="/assets/js/77.e1a029bc.js"><link rel="prefetch" href="/assets/js/78.ec41973a.js"><link rel="prefetch" href="/assets/js/79.a8436b64.js"><link rel="prefetch" href="/assets/js/8.d1c35f37.js"><link rel="prefetch" href="/assets/js/80.70d752cd.js"><link rel="prefetch" href="/assets/js/81.5392aaa4.js"><link rel="prefetch" href="/assets/js/82.87f6938e.js"><link rel="prefetch" href="/assets/js/83.9efaf755.js"><link rel="prefetch" href="/assets/js/84.d0bba92a.js"><link rel="prefetch" href="/assets/js/85.f8f968c5.js"><link rel="prefetch" href="/assets/js/86.9e5296f6.js"><link rel="prefetch" href="/assets/js/87.8774d4bd.js"><link rel="prefetch" href="/assets/js/88.7513e6b5.js"><link rel="prefetch" href="/assets/js/89.421b5237.js"><link rel="prefetch" href="/assets/js/9.220b3eb6.js"><link rel="prefetch" href="/assets/js/90.47497ac9.js"><link rel="prefetch" href="/assets/js/91.20e7b656.js"><link rel="prefetch" href="/assets/js/92.ab742aa0.js"><link rel="prefetch" href="/assets/js/93.6f6eef2e.js"><link rel="prefetch" href="/assets/js/94.b8ff20d8.js"><link rel="prefetch" href="/assets/js/95.e97d80de.js"><link rel="prefetch" href="/assets/js/96.7f9bfe96.js"><link rel="prefetch" href="/assets/js/97.5bc5b95e.js"><link rel="prefetch" href="/assets/js/98.07280354.js"><link rel="prefetch" href="/assets/js/99.be9ded95.js">
    <link rel="stylesheet" href="/assets/css/0.styles.34788bb2.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">NodeJS</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/core/" class="nav-link">Node</a></div><div class="nav-item"><a href="/packageManager/" class="nav-link">Manager</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Nestjs" class="dropdown-title"><span class="title">Nestjs</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/framework/nestjs/office-docs/" class="nav-link router-link-active">NestJS 官方文档</a></li><li class="dropdown-item"><!----> <a href="/nestjs/source-codes/" class="nav-link">NestJS 源码</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="framework" class="dropdown-title"><span class="title">framework</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/framework/egg/" class="nav-link">egg</a></li><li class="dropdown-item"><!----> <a href="/framework/express/" class="nav-link">express</a></li><li class="dropdown-item"><!----> <a href="/framework/fasitify/" class="nav-link">fasitify</a></li><li class="dropdown-item"><!----> <a href="/framework/hapi/" class="nav-link">hapi</a></li><li class="dropdown-item"><!----> <a href="/framework/koa/" class="nav-link">koa</a></li><li class="dropdown-item"><!----> <a href="/framework/midway/" class="nav-link">midway</a></li></ul></div></div><div class="nav-item"><a href="/graphql/" class="nav-link">graphql</a></div><div class="nav-item"><a href="/TypeORM/" class="nav-link">TypeORM</a></div><div class="nav-item"><a href="/branchmark/" class="nav-link">性能</a></div><div class="nav-item"><a href="/vendor/" class="nav-link">第三方包</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/core/" class="nav-link">Node</a></div><div class="nav-item"><a href="/packageManager/" class="nav-link">Manager</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Nestjs" class="dropdown-title"><span class="title">Nestjs</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/framework/nestjs/office-docs/" class="nav-link router-link-active">NestJS 官方文档</a></li><li class="dropdown-item"><!----> <a href="/nestjs/source-codes/" class="nav-link">NestJS 源码</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="framework" class="dropdown-title"><span class="title">framework</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/framework/egg/" class="nav-link">egg</a></li><li class="dropdown-item"><!----> <a href="/framework/express/" class="nav-link">express</a></li><li class="dropdown-item"><!----> <a href="/framework/fasitify/" class="nav-link">fasitify</a></li><li class="dropdown-item"><!----> <a href="/framework/hapi/" class="nav-link">hapi</a></li><li class="dropdown-item"><!----> <a href="/framework/koa/" class="nav-link">koa</a></li><li class="dropdown-item"><!----> <a href="/framework/midway/" class="nav-link">midway</a></li></ul></div></div><div class="nav-item"><a href="/graphql/" class="nav-link">graphql</a></div><div class="nav-item"><a href="/TypeORM/" class="nav-link">TypeORM</a></div><div class="nav-item"><a href="/branchmark/" class="nav-link">性能</a></div><div class="nav-item"><a href="/vendor/" class="nav-link">第三方包</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>总览-OVERVIEW</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>基本原理 - Fundamentals</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>技术技巧 - Techniques</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>Graphql</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/framework/nestjs/office-docs/04-graphql/01-quickStart.html" class="sidebar-link">利用 TypeScript 和 GraphQL 的力量</a></li><li><a href="/framework/nestjs/office-docs/04-graphql/02-resolvers.html" class="active sidebar-link">解释器 =&gt; Resolvers</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/framework/nestjs/office-docs/04-graphql/02-resolvers.html#代码第一-code-first" class="sidebar-link">代码第一 =&gt; Code first</a></li><li class="sidebar-sub-header"><a href="/framework/nestjs/office-docs/04-graphql/02-resolvers.html#代码优先解释器-code-first-resolver" class="sidebar-link">代码优先解释器 =&gt; Code first resolver</a></li><li class="sidebar-sub-header"><a href="/framework/nestjs/office-docs/04-graphql/02-resolvers.html#查询类型名-query-type-names" class="sidebar-link">查询类型名 =&gt; Query type names</a></li><li class="sidebar-sub-header"><a href="/framework/nestjs/office-docs/04-graphql/02-resolvers.html#查询装饰器选项-query-decorator-options" class="sidebar-link">查询装饰器选项 =&gt; Query decorator options</a></li><li class="sidebar-sub-header"><a href="/framework/nestjs/office-docs/04-graphql/02-resolvers.html#参数装饰器选项-args-decorator-options" class="sidebar-link">参数装饰器选项 =&gt; Args decorator options</a></li><li class="sidebar-sub-header"><a href="/framework/nestjs/office-docs/04-graphql/02-resolvers.html#专用参数类-dedicated-arguments-class" class="sidebar-link">专用参数类 =&gt; Dedicated arguments class</a></li><li class="sidebar-sub-header"><a href="/framework/nestjs/office-docs/04-graphql/02-resolvers.html#架构优先-schema-first" class="sidebar-link">架构优先 =&gt; Schema first</a></li><li class="sidebar-sub-header"><a href="/framework/nestjs/office-docs/04-graphql/02-resolvers.html#架构第一解释器-schema-first-resolver" class="sidebar-link">架构第一解释器 =&gt; Schema first resolver</a></li><li class="sidebar-sub-header"><a href="/framework/nestjs/office-docs/04-graphql/02-resolvers.html#生成类型-generating-types" class="sidebar-link">生成类型 =&gt; Generating types</a></li><li class="sidebar-sub-header"><a href="/framework/nestjs/office-docs/04-graphql/02-resolvers.html#graphql-参数-graphql-argument-decorators" class="sidebar-link">GraphQL 参数 =&gt; GraphQL argument decorators</a></li><li class="sidebar-sub-header"><a href="/framework/nestjs/office-docs/04-graphql/02-resolvers.html#装饰器-decorators" class="sidebar-link">装饰器 =&gt; Decorators</a></li><li class="sidebar-sub-header"><a href="/framework/nestjs/office-docs/04-graphql/02-resolvers.html#模块-module" class="sidebar-link">模块 =&gt; Module</a></li><li class="sidebar-sub-header"><a href="/framework/nestjs/office-docs/04-graphql/02-resolvers.html#cli-插件-cli-plugin" class="sidebar-link">CLI 插件 =&gt; CLI Plugin</a></li></ul></li><li><a href="/framework/nestjs/office-docs/04-graphql/03-mutations.html" class="sidebar-link">变异 Mutations</a></li><li><a href="/framework/nestjs/office-docs/04-graphql/04-Subscriptions.html" class="sidebar-link">订阅内容 Subscriptions</a></li><li><a href="/framework/nestjs/office-docs/04-graphql/05-scalars.html" class="sidebar-link">标量 Scalars</a></li><li><a href="/framework/nestjs/office-docs/04-graphql/06-Directives.html" class="sidebar-link">指令 Directives</a></li><li><a href="/framework/nestjs/office-docs/04-graphql/07-Plugins.html" class="sidebar-link">插件 =&gt; Plugins</a></li><li><a href="/framework/nestjs/office-docs/04-graphql/08-interfaces.html" class="sidebar-link">接口 =&gt; Interfaces</a></li><li><a href="/framework/nestjs/office-docs/04-graphql/09-Unions.html" class="sidebar-link">联合 Unions</a></li><li><a href="/framework/nestjs/office-docs/04-graphql/10-Enums.html" class="sidebar-link">枚举 =&gt; Enums</a></li><li><a href="/framework/nestjs/office-docs/04-graphql/11-OtherFeatures.html" class="sidebar-link">其它特性 =&gt; Other features</a></li><li><a href="/framework/nestjs/office-docs/04-graphql/12-Federation.html" class="sidebar-link">联邦 Federation</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Web 套接字</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>微服务</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>单 App</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>脚手架 CLI</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>食谱 Recipes</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>FQA</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="解释器-resolvers"><a href="#解释器-resolvers" class="header-anchor">#</a> 解释器 =&gt; Resolvers</h1> <p>解析器提供了将GraphQL操作（查询，变异或订阅）转换为数据的说明。它们返回与我们在架构中指定的数据相同的形状-同步地或作为解决该形状结果的承诺。通常，您可以手动创建解析器映射。@nestjs/graphql另一方面，该程序包使用用于注释类的装饰器提供的元数据自动生成解析器映射。为了演示使用包功能创建GraphQL API的过程，我们将创建一个简单的authors API。</p> <h2 id="代码第一-code-first"><a href="#代码第一-code-first" class="header-anchor">#</a> 代码第一 =&gt; Code first</h2> <p>在代码优先方法中，我们没有遵循手工编写GraphQL SDL来创建GraphQL模式的典型过程。相反，我们使用TypeScript装饰器从TypeScript类定义生成SDL。的@nestjs/graphql包中读取通过所述装饰定义的元数据，并自动生成的模式为您服务。</p> <p>如果我们使用模式优先方法，则可以使用SDL定义这样的模式，如下所示：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">type</span> Author <span class="token punctuation">{</span>
  id<span class="token operator">:</span> Int<span class="token operator">!</span>
  firstName<span class="token operator">:</span> String
  lastName<span class="token operator">:</span> String
  posts<span class="token operator">:</span> <span class="token punctuation">[</span>Post<span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在这种情况下，使用代码优先方法，我们使用TypeScript类和TypeScript装饰器定义模式来注释那些类的字段。代码优先方法中上述SDL的等效项是：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token comment">// authors/models/author.model.tsJS</span>

<span class="token keyword">import</span> <span class="token punctuation">{</span> Field<span class="token punctuation">,</span> Int<span class="token punctuation">,</span> ObjectType <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'@nestjs/graphql'</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> Post <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./post'</span><span class="token punctuation">;</span>

@<span class="token function">ObjectType</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">Author</span> <span class="token punctuation">{</span>
  @<span class="token function">Field</span><span class="token punctuation">(</span><span class="token parameter"><span class="token keyword">type</span></span> <span class="token operator">=&gt;</span> Int<span class="token punctuation">)</span>
  id<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>

  @<span class="token function">Field</span><span class="token punctuation">(</span><span class="token punctuation">{</span> nullable<span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
  firstName<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>

  @<span class="token function">Field</span><span class="token punctuation">(</span><span class="token punctuation">{</span> nullable<span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
  lastName<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>

  @<span class="token function">Field</span><span class="token punctuation">(</span><span class="token parameter"><span class="token keyword">type</span></span> <span class="token operator">=&gt;</span> <span class="token punctuation">[</span>Post<span class="token punctuation">]</span><span class="token punctuation">)</span>
  posts<span class="token operator">:</span> Post<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>提示
TypeScript的元数据反射系统具有多个限制，这些限制使得无法确定类所包含的属性或识别给定的属性是可选属性还是必需属性。由于这些限制，我们必须@Field()在架构定义类中显式使用装饰器来提供有关每个字段的GraphQL类型和可选性的元数据，或者使用CLI插件为我们生成这些。</p></div> <p>的Author对象类型，像任何类，由字段的集合，其中每个字段声明一个类型。字段的类型对应于GraphQL类型。字段的GraphQL类型可以是其他对象类型或标量类型。甲GraphQL标量类型是基本（如ID，String，Boolean，或Int）解析为一个单一的值。</p> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>提示
除了GraphQL的内置标量类型，您还可以定义自定义标量类型（了解更多信息）。</p></div> <p>上面的Author对象类型定义将使Nest 生成我们上面显示的SDL：</p> <div class="language- extra-class"><pre class="language-text"><code>type Author {
  id: Int!
  firstName: String
  lastName: String
  posts: [Post]
}
</code></pre></div><p>所述@Field()装饰接受可选类型的功能（例如，type =&gt; Int），和任选的选项对象。</p> <p>如果TypeScript类型系统和GraphQL类型系统之间可能存在歧义，则需要使用type函数。具体来说：和类型不是必需的；它是必需的阵列，数字（它必须被映射到任何一个GraphQL 或）和对象类型。类型函数应该简单地返回所需的GraphQL类型（如本章各示例所示）。stringbooleanIntFloat</p> <p>选项对象可以具有以下任何键/值对：</p> <p>nullable：用于指定字段是否可为空（在SDL中，每个字段默认情况下均不可为空）； boolean
description：用于设置字段描述； string
deprecationReason：用于将字段标记为已弃用； string
例如：</p> <div class="language-ts extra-class"><pre class="language-ts"><code>@<span class="token function">Field</span><span class="token punctuation">(</span><span class="token punctuation">{</span> description<span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Book title</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span> deprecationReason<span class="token operator">:</span> <span class="token string">'Not useful in v2 schema'</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
title<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
</code></pre></div><div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>提示
您还可以为整个对象类型添加描述或不赞成使用：@ObjectType({ description: 'Author model' })。</p></div> <p>当字段是数组时，我们必须在Field()装饰器的type函数中手动指示数组类型，如下所示：</p> <div class="language-ts extra-class"><pre class="language-ts"><code>@<span class="token function">Field</span><span class="token punctuation">(</span><span class="token parameter"><span class="token keyword">type</span></span> <span class="token operator">=&gt;</span> <span class="token punctuation">[</span>Post<span class="token punctuation">]</span><span class="token punctuation">)</span>
posts<span class="token operator">:</span> Post<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre></div><div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>提示
使用数组括号符号（[ ]），我们可以指示数组的深度。例如，使用[[Int]]将表示一个整数矩阵。</p></div> <p>要声明数组的项目（而不是数组本身）为空，请将nullable属性设置'items'为，如下所示：</p> <div class="language-ts extra-class"><pre class="language-ts"><code>@<span class="token function">Field</span><span class="token punctuation">(</span><span class="token parameter"><span class="token keyword">type</span></span> <span class="token operator">=&gt;</span> <span class="token punctuation">[</span>Post<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> nullable<span class="token operator">:</span> <span class="token string">'items'</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
posts<span class="token operator">:</span> Post<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre></div><div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>提示
如果数组及其项都可以为空，则设置nullable为'itemsAndList'。</p></div> <p>现在Author已经创建了对象类型，让我们定义Post对象类型。</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token comment">// posts/models/post.model.ts</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> Field<span class="token punctuation">,</span> Int<span class="token punctuation">,</span> ObjectType <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'@nestjs/graphql'</span><span class="token punctuation">;</span>

@<span class="token function">ObjectType</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">Post</span> <span class="token punctuation">{</span>
  @<span class="token function">Field</span><span class="token punctuation">(</span><span class="token parameter"><span class="token keyword">type</span></span> <span class="token operator">=&gt;</span> Int<span class="token punctuation">)</span>
  id<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>

  @<span class="token function">Field</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  title<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>

  @<span class="token function">Field</span><span class="token punctuation">(</span><span class="token parameter"><span class="token keyword">type</span></span> <span class="token operator">=&gt;</span> Int<span class="token punctuation">,</span> <span class="token punctuation">{</span> nullable<span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
  votes<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>Post对象类型将导致产生在SDL的GraphQL模式的以下部分：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">type</span> Post <span class="token punctuation">{</span>
  id<span class="token operator">:</span> Int<span class="token operator">!</span>
  title<span class="token operator">:</span> String<span class="token operator">!</span>
  votes<span class="token operator">:</span> Int
<span class="token punctuation">}</span>

</code></pre></div><h2 id="代码优先解释器-code-first-resolver"><a href="#代码优先解释器-code-first-resolver" class="header-anchor">#</a> 代码优先解释器 =&gt; Code first resolver</h2> <p>至此，我们已经定义了可以存在于数据图中的对象（类型定义），但是客户端尚无法与这些对象进行交互。为了解决这个问题，我们需要创建一个解析器类。在代码优先方法中，解析程序类既定义解析程序功能，又生成查询类型。通过下面的示例，这一点将很明显：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token comment">// authors/authors.resolver.ts</span>

@<span class="token function">Resolver</span><span class="token punctuation">(</span><span class="token parameter"><span class="token keyword">of</span></span> <span class="token operator">=&gt;</span> Author<span class="token punctuation">)</span>
<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">AuthorsResolver</span> <span class="token punctuation">{</span>
  <span class="token keyword">constructor</span><span class="token punctuation">(</span>
    <span class="token parameter"><span class="token keyword">private</span> authorsService<span class="token operator">:</span> AuthorsService<span class="token punctuation">,</span>
    <span class="token keyword">private</span> postsService<span class="token operator">:</span> PostsService<span class="token punctuation">,</span></span>
  <span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

  @<span class="token function">Query</span><span class="token punctuation">(</span><span class="token parameter">returns</span> <span class="token operator">=&gt;</span> Author<span class="token punctuation">)</span>
  <span class="token keyword">async</span> <span class="token function">author</span><span class="token punctuation">(</span>@<span class="token function">Args</span><span class="token punctuation">(</span><span class="token string">'id'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token function-variable function">type</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> Int <span class="token punctuation">}</span><span class="token punctuation">)</span> id<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>authorsService<span class="token punctuation">.</span><span class="token function">findOneById</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  @<span class="token function">ResolveField</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token keyword">async</span> <span class="token function">posts</span><span class="token punctuation">(</span><span class="token parameter">@<span class="token function">Parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> author<span class="token operator">:</span> Author</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> <span class="token punctuation">{</span> id <span class="token punctuation">}</span> <span class="token operator">=</span> author<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>postsService<span class="token punctuation">.</span><span class="token function">findAll</span><span class="token punctuation">(</span><span class="token punctuation">{</span> authorId<span class="token operator">:</span> id <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>HINT
All decorators (e.g., @Resolver, @ResolveField, @Args, etc.) are exported from the @nestjs/graphql package.</p></div> <p>您可以定义多个解析器类。Nest将在运行时将它们结合在一起。有关代码组织的更多信息，请参见下面的模块部分。</p> <div class="custom-block warning"><p class="custom-block-title">WARNING</p> <p>注意
AuthorsService和PostsService类中的逻辑可以根据需要简单或复杂。此示例的重点是显示如何构造解析器以及它们如何与其他提供程序进行交互。</p></div> <p>在上面的示例中，我们创建了AuthorsResolver，定义了一个查询解析器功能和一个字段解析器功能。要创建解析器，我们创建一个以解析器函数为方法的类，并用@Resolver()装饰器注释该类。</p> <p>在此示例中，我们定义了一个查询处理程序，以基于id请求中发送的内容来获取作者对象。要指定该方法是查询处理程序，请使用@Query()装饰器。</p> <p>传递给@Resolver()装饰器的参数是可选的，但在我们的图形变得平凡时会起作用。它用于提供字段解析器功能遍历对象图时所使用的父对象。</p> <p>在我们的示例中，由于类包括一个字段解析器函数（针对对象类型的posts属性Author），因此我们必须为@Resolver()装饰器提供一个值，以指示ObjectType所有字段解析器的父类是哪个类（即对应的类名称）在此类中定义。从示例中应该可以清楚地看到，在编写字段解析器函数时，必须访问父对象（要解析的字段是其成员的对象）。在此示例中，我们使用字段解析器填充作者的posts数组，该字段解析器调用将作者的id作为参数的服务。因此，需要在@Resolver()装饰器中标识父对象。注意的相应用法@Parent() 方法参数修饰器，然后在字段解析器中提取对该父对象的引用。</p> <p>我们可以定义多个@Query()解析器函数（在此类中以及在任何其他解析器类中），并且它们将与解析器映射中的相应条目一起聚合到生成的SDL中的单个查询类型定义中。这使您可以在查询所使用的模型和服务附近对其进行定义，并使查询在模块中井井有条。</p> <h2 id="查询类型名-query-type-names"><a href="#查询类型名-query-type-names" class="header-anchor">#</a> 查询类型名 =&gt; Query type names</h2> <p>在以上示例中，@Query()装饰器根据方法名称生成GraphQL模式查询类型名称。例如，从上面的示例考虑以下构造：</p> <div class="language-ts extra-class"><pre class="language-ts"><code>@<span class="token function">Query</span><span class="token punctuation">(</span><span class="token parameter">returns</span> <span class="token operator">=&gt;</span> Author<span class="token punctuation">)</span>
<span class="token keyword">async</span> <span class="token function">author</span><span class="token punctuation">(</span>@<span class="token function">Args</span><span class="token punctuation">(</span><span class="token string">'id'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token function-variable function">type</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> Int <span class="token punctuation">}</span><span class="token punctuation">)</span> id<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>authorsService<span class="token punctuation">.</span><span class="token function">findOneById</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这将在我们的架构中为作者查询生成以下条目（查询类型使用与方法名称相同的名称）：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">type</span> Query <span class="token punctuation">{</span>
  <span class="token function">author</span><span class="token punctuation">(</span>id<span class="token operator">:</span> Int<span class="token operator">!</span><span class="token punctuation">)</span><span class="token operator">:</span> Author
<span class="token punctuation">}</span>
</code></pre></div><div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>提示
在此处了解有关GraphQL查询的更多信息。</p></div> <p>按照惯例，我们倾向于将这些名称分离。例如，我们更喜欢getAuthor()为我们的查询处理程序方法使用类似的名称，但仍为author我们的查询类型名称使用。这同样适用于我们的现场解析器。我们可以通过将映射名称作为@Query()和@ResolveField()装饰器的参数传递来轻松地做到这一点，如下所示</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token comment">// authors / authors.resolver.ts</span>

@<span class="token function">Resolver</span><span class="token punctuation">(</span><span class="token parameter"><span class="token keyword">of</span></span> <span class="token operator">=&gt;</span> Author<span class="token punctuation">)</span>
<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">AuthorsResolver</span> <span class="token punctuation">{</span>
  <span class="token keyword">constructor</span><span class="token punctuation">(</span>
    <span class="token parameter"><span class="token keyword">private</span> authorsService<span class="token operator">:</span> AuthorsService<span class="token punctuation">,</span>
    <span class="token keyword">private</span> postsService<span class="token operator">:</span> PostsService<span class="token punctuation">,</span></span>
  <span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

  @<span class="token function">Query</span><span class="token punctuation">(</span><span class="token parameter">returns</span> <span class="token operator">=&gt;</span> Author<span class="token punctuation">,</span> <span class="token punctuation">{</span> name<span class="token operator">:</span> <span class="token string">'author'</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token keyword">async</span> <span class="token function">getAuthor</span><span class="token punctuation">(</span>@<span class="token function">Args</span><span class="token punctuation">(</span><span class="token string">'id'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token function-variable function">type</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> Int <span class="token punctuation">}</span><span class="token punctuation">)</span> id<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>authorsService<span class="token punctuation">.</span><span class="token function">findOneById</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  @<span class="token function">ResolveField</span><span class="token punctuation">(</span><span class="token string">'posts'</span><span class="token punctuation">,</span> <span class="token parameter">returns</span> <span class="token operator">=&gt;</span> <span class="token punctuation">[</span>Post<span class="token punctuation">]</span><span class="token punctuation">)</span>
  <span class="token keyword">async</span> <span class="token function">getPosts</span><span class="token punctuation">(</span><span class="token parameter">@<span class="token function">Parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> author<span class="token operator">:</span> Author</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> <span class="token punctuation">{</span> id <span class="token punctuation">}</span> <span class="token operator">=</span> author<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>postsService<span class="token punctuation">.</span><span class="token function">findAll</span><span class="token punctuation">(</span><span class="token punctuation">{</span> authorId<span class="token operator">:</span> id <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>getAuthor上面的处理程序方法将导致在SDL中生成GraphQL模式的以下部分：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">type</span> Query <span class="token punctuation">{</span>
  <span class="token function">author</span><span class="token punctuation">(</span>id<span class="token operator">:</span> Int<span class="token operator">!</span><span class="token punctuation">)</span><span class="token operator">:</span> Author
<span class="token punctuation">}</span>

</code></pre></div><h2 id="查询装饰器选项-query-decorator-options"><a href="#查询装饰器选项-query-decorator-options" class="header-anchor">#</a> 查询装饰器选项 =&gt; Query decorator options</h2> <p>该@Query()装饰器的选项对象（在这里我们通过{name: 'author'}以上）接受一个数字键/值对：</p> <p>name：查询名称；一种string
description：将用于生成GraphQL模式文档的描述（例如，在GraphQL游乐场中）；一种string
deprecationReason：设置查询元数据以显示已弃用的查询（例如，在GraphQL游乐场中）；一种string
nullable：查询是否可以返回空数据响应；boolean或'items'或'itemsAndList'（有关'items'和的详细信息，请参见上文'itemsAndList'）</p> <h2 id="参数装饰器选项-args-decorator-options"><a href="#参数装饰器选项-args-decorator-options" class="header-anchor">#</a> 参数装饰器选项 =&gt; Args decorator options</h2> <p>使用@Args()装饰器从请求中提取参数以在方法处理程序中使用。这与REST路由参数参数提取非常相似。</p> <p>通常，您的@Args()装饰器将很简单，并且不需要使用上述getAuthor()方法中的对象参数。例如，如果标识符的类型为字符串，则下面的构造就足够了，只需从入站GraphQL请求中抽取命名字段作为方法参数即可。</p> <div class="language-ts extra-class"><pre class="language-ts"><code>@<span class="token function">Args</span><span class="token punctuation">(</span><span class="token string">'id'</span><span class="token punctuation">)</span> id<span class="token operator">:</span> <span class="token builtin">string</span>
</code></pre></div><p>在这种getAuthor()情况下，使用number类型，这是一个挑战。该number打字稿类型不给我们介绍一下预期GraphQL表示（例如，足够的信息Int对Float）。因此，我们必须显式传递类型引用。为此，我们将第二个参数传递给Args()包含参数选项的装饰器，如下所示：</p> <div class="language-ts extra-class"><pre class="language-ts"><code>@<span class="token function">Query</span><span class="token punctuation">(</span><span class="token parameter">returns</span> <span class="token operator">=&gt;</span> Author<span class="token punctuation">,</span> <span class="token punctuation">{</span> name<span class="token operator">:</span> <span class="token string">'author'</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token keyword">async</span> <span class="token function">getAuthor</span><span class="token punctuation">(</span>@<span class="token function">Args</span><span class="token punctuation">(</span><span class="token string">'id'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token function-variable function">type</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> Int <span class="token punctuation">}</span><span class="token punctuation">)</span> id<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>authorsService<span class="token punctuation">.</span><span class="token function">findOneById</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
</code></pre></div><p>options对象允许我们指定以下可选键值对：</p> <p>type：返回GraphQL类型的函数
defaultValue：默认值； any
description：描述元数据； string
deprecationReason：弃用一个字段并提供描述原因的元数据； string
nullable：该字段是否可为空
查询处理程序方法可以采用多个参数。让我们想象一下，我们想根据其firstName和来获取作者lastName。在这种情况下，我们可以拨打@Args两次</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token function">getAuthor</span><span class="token punctuation">(</span>
  @<span class="token function">Args</span><span class="token punctuation">(</span> <span class="token string">'firstName'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> nullable<span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">)</span> firstName<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span>
  @<span class="token function">Args</span><span class="token punctuation">(</span> <span class="token string">'lastName'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> defaultValue<span class="token operator">:</span> <span class="token string">''</span> <span class="token punctuation">}</span><span class="token punctuation">)</span> lastName<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span>
<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre></div><h2 id="专用参数类-dedicated-arguments-class"><a href="#专用参数类-dedicated-arguments-class" class="header-anchor">#</a> 专用参数类 =&gt; Dedicated arguments class</h2> <p>通过内联@Args()调用，上面示例中的代码变得肿。相反，您可以创建一个专用的GetAuthorArgs参数类，并在处理程序方法中按如下方式访问它：</p> <div class="language-ts extra-class"><pre class="language-ts"><code>@<span class="token function">Args</span><span class="token punctuation">(</span><span class="token punctuation">)</span> args<span class="token operator">:</span> GetAuthorArgs
</code></pre></div><p>GetAuthorArgs使用@ArgsType()如下所示创建类：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token comment">// authors / dto / get-author.args.ts</span>

<span class="token keyword">import</span> <span class="token punctuation">{</span> MinLength <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'class-validator'</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> Field<span class="token punctuation">,</span> ArgsType <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'@nestjs/graphql'</span><span class="token punctuation">;</span>

@<span class="token function">ArgsType</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">class</span> <span class="token class-name">GetAuthorArgs</span> <span class="token punctuation">{</span>
  @<span class="token function">Field</span><span class="token punctuation">(</span><span class="token punctuation">{</span> nullable<span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
  firstName<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>

  @<span class="token function">Field</span><span class="token punctuation">(</span><span class="token punctuation">{</span> defaultValue<span class="token operator">:</span> <span class="token string">''</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
  @<span class="token function">MinLength</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>
  lastName<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>提示
再次，由于TypeScript的元数据反射系统的限制，需要使用@Field装饰器来手动指示类型和可选性，或者使用CLI插件。</p></div> <p>这将导致在SDL中生成GraphQL模式的以下部分：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">type</span> Query <span class="token punctuation">{</span>
  <span class="token function">author</span><span class="token punctuation">(</span>firstName<span class="token operator">:</span> String<span class="token punctuation">,</span> lastName<span class="token operator">:</span> String <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">)</span><span class="token operator">:</span> Author
<span class="token punctuation">}</span>
</code></pre></div><p>提示
请注意，类似的参数类GetAuthorArgs在ValidationPipe（阅读更多）中可以很好地发挥作用。</p> <h2 id="架构优先-schema-first"><a href="#架构优先-schema-first" class="header-anchor">#</a> 架构优先 =&gt; Schema first</h2> <p>正如提到以前的章节，在该模式中第一种方法，我们通过手动定义在SDL模式类型（读取启动更多）。考虑以下SDL类型定义。</p> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>正如提到以前的章节，在该模式中第一种方法，我们通过手动定义在SDL模式类型（读取启动更多）。考虑以下SDL类型定义。</p></div> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">type</span> Author <span class="token punctuation">{</span>
  id<span class="token operator">:</span> Int<span class="token operator">!</span>
  firstName<span class="token operator">:</span> String
  lastName<span class="token operator">:</span> String
  posts<span class="token operator">:</span> <span class="token punctuation">[</span>Post<span class="token punctuation">]</span>
<span class="token punctuation">}</span>

<span class="token keyword">type</span> Post <span class="token punctuation">{</span>
  id<span class="token operator">:</span> Int<span class="token operator">!</span>
  title<span class="token operator">:</span> String<span class="token operator">!</span>
  votes<span class="token operator">:</span> Int
<span class="token punctuation">}</span>

<span class="token keyword">type</span> Query <span class="token punctuation">{</span>
  <span class="token function">author</span><span class="token punctuation">(</span>id<span class="token operator">:</span> Int<span class="token operator">!</span><span class="token punctuation">)</span><span class="token operator">:</span> Author
<span class="token punctuation">}</span>
</code></pre></div><h2 id="架构第一解释器-schema-first-resolver"><a href="#架构第一解释器-schema-first-resolver" class="header-anchor">#</a> 架构第一解释器 =&gt; Schema first resolver</h2> <p>上面的架构公开了一个查询- author(id: Int!): Author。</p> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>提示
在此处了解有关GraphQL查询的更多信息。</p></div> <p>现在让我们创建一个AuthorsResolver解决作者查询的类：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token comment">// authors / authors.resolver.ts</span>

@<span class="token function">Resolver</span><span class="token punctuation">(</span><span class="token string">'Author'</span><span class="token punctuation">)</span>
<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">AuthorsResolver</span> <span class="token punctuation">{</span>
  <span class="token keyword">constructor</span><span class="token punctuation">(</span>
    <span class="token parameter"><span class="token keyword">private</span> authorsService<span class="token operator">:</span> AuthorsService<span class="token punctuation">,</span>
    <span class="token keyword">private</span> postsService<span class="token operator">:</span> PostsService<span class="token punctuation">,</span></span>
  <span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

  @<span class="token function">Query</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token keyword">async</span> <span class="token function">author</span><span class="token punctuation">(</span>@<span class="token function">Args</span><span class="token punctuation">(</span><span class="token string">'id'</span><span class="token punctuation">)</span> id<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>authorsService<span class="token punctuation">.</span><span class="token function">findOneById</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  @<span class="token function">ResolveField</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token keyword">async</span> <span class="token function">posts</span><span class="token punctuation">(</span><span class="token parameter">@<span class="token function">Parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> author</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> <span class="token punctuation">{</span> id <span class="token punctuation">}</span> <span class="token operator">=</span> author<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>postsService<span class="token punctuation">.</span><span class="token function">findAll</span><span class="token punctuation">(</span><span class="token punctuation">{</span> authorId<span class="token operator">:</span> id <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>提示
所有装饰（例如，@Resolver，@ResolveField，@Args，等等）从出口@nestjs/graphql包。</p></div> <div class="custom-block warning"><p class="custom-block-title">WARNING</p> <p>注意
AuthorsService和PostsService类中的逻辑可以根据需要简单或复杂。此示例的重点是显示如何构造解析器以及它们如何与其他提供程序进行交互。</p></div> <p>该@Resolver()装饰是必需的。它带有一个带有类名的可选字符串参数。只要该类包含@ResolveField()装饰器来通知Nest所装饰的方法与父类型（Author在当前示例中为该类型）相关联，就必须使用该类名称。另外，@Resolver()也可以对每个方法进行设置，而不是在类的顶部进行设置：</p> <div class="language-ts extra-class"><pre class="language-ts"><code>@<span class="token function">Resolver</span><span class="token punctuation">(</span><span class="token string">'Author'</span><span class="token punctuation">)</span>
@<span class="token function">ResolveField</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">async</span> <span class="token function">posts</span><span class="token punctuation">(</span><span class="token parameter">@<span class="token function">Parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> author</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">{</span> id <span class="token punctuation">}</span> <span class="token operator">=</span> author<span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>postsService<span class="token punctuation">.</span><span class="token function">findAll</span><span class="token punctuation">(</span><span class="token punctuation">{</span> authorId<span class="token operator">:</span> id <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在这种情况下（@Resolver()方法级别的装饰器），如果@ResolveField()一个类中有多个装饰器，则必须将@Resolver()它们全部添加。这不是最佳做法（因为这会产生额外的开销）。</p> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>提示
传递给任何类名参数@Resolver()不会影响查询（@Query()装饰器）或突变（@Mutation()装饰器）。</p></div> <div class="custom-block warning"><p class="custom-block-title">WARNING</p> <p>警告
代码优先
方法@Resolver不支持在方法级别使用修饰器。</p></div> <p>在以上示例中，@Query()和@ResolveField()装饰器基于方法名称与GraphQL模式类型相关联。例如，从上面的示例考虑以下构造:</p> <div class="language-ts extra-class"><pre class="language-ts"><code>@<span class="token function">Query</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">async</span> <span class="token function">author</span><span class="token punctuation">(</span>@<span class="token function">Args</span><span class="token punctuation">(</span><span class="token string">'id'</span><span class="token punctuation">)</span> id<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>authorsService<span class="token punctuation">.</span><span class="token function">findOneById</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这将在我们的架构中为作者查询生成以下条目（查询类型使用与方法名称相同的名称）：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">type</span> Query <span class="token punctuation">{</span>
  <span class="token function">author</span><span class="token punctuation">(</span>id<span class="token operator">:</span> Int<span class="token operator">!</span><span class="token punctuation">)</span><span class="token operator">:</span> Author
<span class="token punctuation">}</span>
</code></pre></div><p>按照惯例，我们宁愿去耦这些，使用类似名称getAuthor()或getPosts()为我们解析方法。我们可以通过将映射名称作为参数传递给装饰器来轻松地做到这一点，如下所示</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token comment">// authors / authors.resolver.ts.ts</span>

@<span class="token function">Resolver</span><span class="token punctuation">(</span><span class="token string">'Author'</span><span class="token punctuation">)</span>
<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">AuthorsResolver</span> <span class="token punctuation">{</span>
  <span class="token keyword">constructor</span><span class="token punctuation">(</span>
    <span class="token parameter"><span class="token keyword">private</span> authorsService<span class="token operator">:</span> AuthorsService<span class="token punctuation">,</span>
    <span class="token keyword">private</span> postsService<span class="token operator">:</span> PostsService<span class="token punctuation">,</span></span>
  <span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

  @<span class="token function">Query</span><span class="token punctuation">(</span><span class="token string">'author'</span><span class="token punctuation">)</span>
  <span class="token keyword">async</span> <span class="token function">getAuthor</span><span class="token punctuation">(</span>@<span class="token function">Args</span><span class="token punctuation">(</span><span class="token string">'id'</span><span class="token punctuation">)</span> id<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>authorsService<span class="token punctuation">.</span><span class="token function">findOneById</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  @<span class="token function">ResolveField</span><span class="token punctuation">(</span><span class="token string">'posts'</span><span class="token punctuation">)</span>
  <span class="token keyword">async</span> <span class="token function">getPosts</span><span class="token punctuation">(</span><span class="token parameter">@<span class="token function">Parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> author</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> <span class="token punctuation">{</span> id <span class="token punctuation">}</span> <span class="token operator">=</span> author<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>postsService<span class="token punctuation">.</span><span class="token function">findAll</span><span class="token punctuation">(</span><span class="token punctuation">{</span> authorId<span class="token operator">:</span> id <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="生成类型-generating-types"><a href="#生成类型-generating-types" class="header-anchor">#</a> 生成类型 =&gt; Generating types</h2> <p>假设我们使用的模式第一种方法，并启用了分型生成功能（有outputAs: 'class'如图中前面的章节），一旦你运行它会生成以下文件（在您指定的位置的应用程序GraphQLModule.forRoot()的方法。例如，在src/graphql.ts）</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token comment">// graphql.ts.ts</span>
<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">Author</span> <span class="token punctuation">{</span>
  id<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
  firstName<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
  lastName<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
  posts<span class="token operator">?</span><span class="token operator">:</span> Post<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">Post</span> <span class="token punctuation">{</span>
  id<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
  title<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
  votes<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">export</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">IQuery</span> <span class="token punctuation">{</span>
  <span class="token keyword">abstract</span> <span class="token function">author</span><span class="token punctuation">(</span>id<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span><span class="token operator">:</span> Author <span class="token operator">|</span> <span class="token builtin">Promise</span><span class="token operator">&lt;</span>Author<span class="token operator">&gt;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>通过生成类（而不是默认的生成接口的技术），您可以将声明式验证修饰器与模式优先方法结合使用，这是一种非常有用的技术（了解更多信息）。例如，可以将class-validator装饰器添加到生成的CreatePostInput类中，如下所示，以在title字段上强制使用最小和最大字符串长度：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> MinLength<span class="token punctuation">,</span> MaxLength <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'class-validator'</span><span class="token punctuation">;</span>

<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">CreatePostInput</span> <span class="token punctuation">{</span>
  @<span class="token function">MinLength</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>
  @<span class="token function">MaxLength</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span>
  title<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="custom-block warning"><p class="custom-block-title">WARNING</p> <p>注意
要启用输入（和参数）的自动验证，请使用ValidationPipe。在这里阅读更多关于验证的信息，在这里阅读更多关于管道的信息。</p></div> <p>但是，如果将修饰符直接添加到自动生成的文件中，则每次生成文件时它们都会被覆盖。而是创建一个单独的文件，然后简单地扩展生成的类。</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> MinLength<span class="token punctuation">,</span> MaxLength <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'class-validator'</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> Post <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'../../graphql.ts'</span><span class="token punctuation">;</span>

<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">CreatePostInput</span> <span class="token keyword">extends</span> <span class="token class-name">Post</span> <span class="token punctuation">{</span>
  @<span class="token function">MinLength</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>
  @<span class="token function">MaxLength</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span>
  title<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="graphql-参数-graphql-argument-decorators"><a href="#graphql-参数-graphql-argument-decorators" class="header-anchor">#</a> GraphQL 参数 =&gt; GraphQL argument decorators</h2> <p>我们可以使用专用装饰器访问标准的GraphQL解析器参数。以下是Nest装饰器和它们代表的普通Apollo参数的比较。</p> <table><thead><tr><th style="text-align:left;">装饰器名称</th> <th style="text-align:left;">&amp;&amp;</th></tr></thead> <tbody><tr><td style="text-align:left;">@Root() and @Parent()</td> <td style="text-align:left;">root/parent</td></tr> <tr><td style="text-align:left;">@Context(param?: string)</td> <td style="text-align:left;"><code>context / context[param]</code></td></tr> <tr><td style="text-align:left;">@Info(param?: string)</td> <td style="text-align:left;"><code>info / info[param]</code></td></tr> <tr><td style="text-align:left;">@Args(param?: string)</td> <td style="text-align:left;"><code>args / args[param]</code></td></tr></tbody></table> <p>这些参数具有以下含义：</p> <p>root：一个对象，其中包含从解析程序在父字段上返回的结果，或者在顶级Query字段的情况下包含rootValue从服务器配置传递的结果。
context：在特定查询中所有解析器共享的对象；通常用于包含每个请求状态。
info：包含有关查询执行状态信息的对象。
args：一个对象，其参数传递到查询的字段中。</p> <h2 id="装饰器-decorators"><a href="#装饰器-decorators" class="header-anchor">#</a> 装饰器 =&gt; Decorators</h2> <h2 id="模块-module"><a href="#模块-module" class="header-anchor">#</a> 模块 =&gt; Module</h2> <p>完成上述步骤后，我们以声明方式指定了GraphQLModule生成解析器映射所需的所有信息。在GraphQLModule使用反射来经由装饰提供的元数据，和变换类自动内省到正确的分解图。</p> <p>您需要注意的唯一另一件事是提供（即，provider在某些模块中列出）解析器类（es）（AuthorsResolver），并将模块（AuthorsModule）导入到某个地方，以便Nest可以使用它。</p> <p>例如，我们可以在中执行此操作，AuthorsModule它还可以提供此上下文中所需的其他服务。确保导入AuthorsModule某处（例如，在根模块中或由根模块导入的其他模块中）。</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token comment">// authors / authors.module.tsJS</span>

@<span class="token function">Module</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  imports<span class="token operator">:</span> <span class="token punctuation">[</span>PostsModule<span class="token punctuation">]</span><span class="token punctuation">,</span>
  providers<span class="token operator">:</span> <span class="token punctuation">[</span>AuthorsService<span class="token punctuation">,</span> AuthorsResolver<span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">AuthorsModule</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre></div><div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>提示
通过所谓的域模型来组织代码是很有帮助的（类似于在REST API中组织入口点的方式）。用这种方法，将模型（ObjectType类），解析器和服务放在代表域模型的Nest模块中。将所有这些组件保存在每个模块的单个文件夹中。当您执行此操作并使用Nest CLI生成每个元素时，Nest会自动为您将所有这些部分连接在一起（在适当的文件夹中定位文件，在provider和imports数组中生成条目，等等）。</p></div> <h2 id="cli-插件-cli-plugin"><a href="#cli-插件-cli-plugin" class="header-anchor">#</a> CLI 插件 =&gt; CLI Plugin</h2> <p>TypeScript的元数据反映系统具有多个限制，这些限制使得例如确定类包含哪些属性或识别给定属性是可选属性还是必需属性成为不可能。但是，其中一些约束可以在编译时解决。Nest提供了可增强TypeScript编译过程以减少所需样板代码量的插件。</p> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>提示
此插件是opt-in。如果愿意，可以手动声明所有装饰器，也可以只声明需要的特定装饰器。</p></div> <p>GraphQL插件将自动：</p> <p>@Field除非@HideField使用，否则注释所有输入对象，对象类型和args类属性
nullable根据问号设置属性（例如name?: string将设置nullable: true）
type根据类型设置属性（也支持数组）
请注意，您的文件名必须具有以下后缀之一才能被插件分析：（['.input.ts', '.args.ts', '.entity.ts', '.model.ts']例如，author.entity.ts）。如果使用其他后缀，则可以通过指定typeFileNameSuffix选项来调整插件的行为（请参见下文）。</p> <p>到目前为止，我们已经学到了很多东西，您必须复制很多代码以使程序包知道如何在GraphQL中声明您的类型。例如，您可以定义一个简单的Author类，如下所示：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token comment">// authors/models/author.model.ts</span>

@<span class="token function">ObjectType</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">Author</span> <span class="token punctuation">{</span>
  @<span class="token function">Field</span><span class="token punctuation">(</span><span class="token parameter"><span class="token keyword">type</span></span> <span class="token operator">=&gt;</span> Int<span class="token punctuation">)</span>
  id<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>

  @<span class="token function">Field</span><span class="token punctuation">(</span><span class="token punctuation">{</span> nullable<span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
  firstName<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>

  @<span class="token function">Field</span><span class="token punctuation">(</span><span class="token punctuation">{</span> nullable<span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
  lastName<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>

  @<span class="token function">Field</span><span class="token punctuation">(</span><span class="token parameter"><span class="token keyword">type</span></span> <span class="token operator">=&gt;</span> <span class="token punctuation">[</span>Post<span class="token punctuation">]</span><span class="token punctuation">)</span>
  posts<span class="token operator">:</span> Post<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>对于中型项目而言，这并不是一个大问题，但是一旦您拥有大量的类，它就会变得冗长且难以维护。</p> <p>现在，在启用GraphQL插件的情况下，可以简单地声明上述类定义：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token comment">// authors/models/author.model.ts</span>

@<span class="token function">ObjectType</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">Author</span> <span class="token punctuation">{</span>
  @<span class="token function">Field</span><span class="token punctuation">(</span><span class="token parameter"><span class="token keyword">type</span></span> <span class="token operator">=&gt;</span> Int<span class="token punctuation">)</span>
  id<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
  firstName<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
  lastName<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
  posts<span class="token operator">:</span> Post<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>该插件基于Abstract Syntax Tree即时添加适当的装饰器。因此，您将不必与@Field分散在整个代码中的装饰器作斗争。</p> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>提示
插件将自动生成所有缺少的swagger属性，但是如果您需要覆盖它们，只需通过显式设置它们@Field()。</p></div> <p>要启用该插件，请打开nest-cli.json（如果使用Nest CLI）并添加以下plugins配置：</p> <div class="language-json extra-class"><pre class="language-json"><code><span class="token punctuation">{</span>
  <span class="token property">&quot;collection&quot;</span><span class="token operator">:</span> <span class="token string">&quot;@nestjs/schematics&quot;</span><span class="token punctuation">,</span>
  <span class="token property">&quot;sourceRoot&quot;</span><span class="token operator">:</span> <span class="token string">&quot;src&quot;</span><span class="token punctuation">,</span>
  <span class="token property">&quot;compilerOptions&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token property">&quot;plugins&quot;</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">&quot;@nestjs/graphql/plugin&quot;</span><span class="token punctuation">]</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>您可以使用该options属性来自定义插件的行为。</p> <div class="language-json extra-class"><pre class="language-json"><code><span class="token property">&quot;plugins&quot;</span><span class="token operator">:</span> <span class="token punctuation">[</span>
  <span class="token punctuation">{</span>
    <span class="token property">&quot;name&quot;</span><span class="token operator">:</span> <span class="token string">&quot;@nestjs/graphql/plugin&quot;</span><span class="token punctuation">,</span>
    <span class="token property">&quot;options&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>
      <span class="token property">&quot;typeFileNameSuffix&quot;</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">&quot;.input.ts&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;.args.ts&quot;</span><span class="token punctuation">]</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">]</span>
</code></pre></div><p>该options属性必须满足以下接口：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token keyword">export</span> <span class="token keyword">interface</span> <span class="token class-name">PluginOptions</span> <span class="token punctuation">{</span>
  typeFileNameSuffix<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><table><thead><tr><th style="text-align:left;">选项</th> <th style="text-align:left;">默认</th> <th style="text-align:left;">描述</th></tr></thead> <tbody><tr><td style="text-align:left;">typeFileNameSuffix</td> <td style="text-align:left;">['.input.ts', '.args.ts', '.entity.ts', '.model.ts']</td> <td style="text-align:left;">GraphQL类型文件后缀</td></tr></tbody></table> <p>如果您不使用CLI，而是使用自定义webpack配置，则可以将此插件与ts-loader：</p> <div class="language-ts extra-class"><pre class="language-ts"><code><span class="token function-variable function">getCustomTransformers</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter">program<span class="token operator">:</span> <span class="token builtin">any</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token punctuation">{</span>
  before<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token keyword">require</span><span class="token punctuation">(</span><span class="token string">'@nestjs/graphql/plugin'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">before</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> program<span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
</code></pre></div></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/framework/nestjs/office-docs/04-graphql/01-quickStart.html" class="prev">利用 TypeScript 和 GraphQL 的力量</a></span> <span class="next"><a href="/framework/nestjs/office-docs/04-graphql/03-mutations.html">变异 Mutations</a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.12ca0aa8.js" defer></script><script src="/assets/js/2.74bffc86.js" defer></script><script src="/assets/js/71.00f8f464.js" defer></script>
  </body>
</html>
